--- xcache.orig/ChangeLog
+++ xcache/ChangeLog
@@ -1,3 +1,32 @@
+4.0.0 2014-??-??
+API Changes
+========
+ * new: proto array xcache_get_refcount(mixed &$variable), with +1 side effect removed
+ * chg: proto array xcache_get_cowcount(mixed $value)
+
+ChangeLog
+========
+ * cacher:
+   * (WIP) defragment
+   * (WIP) cache to disk
+   * (WIP) PHP_5_6 support
+ * misc:
+   * Reflection info added for APIs
+
+3.2.0 2013-??-??
+ChangeLog
+========
+ * cacher:
+   * fixed #333: reduce memory usage for small or empty files
+
+3.1.1 2013-??-??
+ChangeLog
+========
+ * cacher
+   * compatible with bcompiler
+ * admin
+   * fixed random 24H counters clear. it's a race cached condition. thanks to the report from Per Hansson
+
 3.1.0 2013-10-10
 ChangeLog
 ========
--- xcache.orig/Makefile.frag
+++ xcache/Makefile.frag
@@ -11,10 +11,11 @@ $(XCACHE_INCLUDES_I):
 
 $(XCACHE_STRUCTINFO_OUT): $(XCACHE_INCLUDES_I) $(srcdir)/gen_structinfo.awk
 	@echo $(XCACHE_STRUCTINFO_OUT) is optional if XCache test is not enabled, feel free if it awk failed to produce it
-	-$(XCACHE_AWK) -f $(srcdir)/gen_structinfo.awk < $(XCACHE_INCLUDES_I) > $(XCACHE_STRUCTINFO_OUT).tmp && mv $(XCACHE_STRUCTINFO_OUT).tmp $(XCACHE_STRUCTINFO_OUT)
+	$(XCACHE_AWK) -f $(srcdir)/gen_structinfo.awk < $(XCACHE_INCLUDES_I) > $(XCACHE_STRUCTINFO_OUT).tmp || echo > $(XCACHE_STRUCTINFO_OUT)
+	mv $(XCACHE_STRUCTINFO_OUT).tmp $(XCACHE_STRUCTINFO_OUT)
 
 $(XCACHE_PROC_OUT): $(XCACHE_PROC_SRC) $(XCACHE_STRUCTINFO_OUT) $(XCACHE_PROC_SOURCES)
-	$(M4) -D srcdir=$(XCACHE_BACKTICK)"$(srcdir)'" -D builddir=$(XCACHE_BACKTICK)"$(builddir)'" $(XCACHE_ENABLE_TEST) $(XCACHE_PROC_SRC) > $(XCACHE_PROC_OUT).tmp
+	$(M4) $(XCACHE_ENABLE_TEST) $(XCACHE_STRUCTINFO_OUT) $(XCACHE_PROC_SRC) > $(XCACHE_PROC_OUT).tmp
 	mv $(XCACHE_PROC_OUT).tmp $(XCACHE_PROC_OUT)
 
 $(XCACHE_PROC_H): $(XCACHE_PROC_OUT)
--- xcache.orig/Makefile.frag.deps
+++ xcache/Makefile.frag.deps
@@ -1,25 +1,25 @@
 $(XCACHE_INCLUDES_I) includes.lo $(builddir)/includes.lo: $(srcdir)/mod_cacher/xc_cache.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h
 mod_assembler/xc_assembler.lo $(builddir)/mod_assembler/xc_assembler.lo:
-mod_cacher/xc_cacher.lo $(builddir)/mod_cacher/xc_cacher.lo: $(srcdir)/mod_cacher/xc_cache.h $(srcdir)/mod_cacher/xc_cacher.h $(srcdir)/util/xc_align.h $(srcdir)/util/xc_stack.h $(srcdir)/util/xc_trace.h $(srcdir)/util/xc_vector.h $(srcdir)/xcache_globals.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_extension.h $(srcdir)/xcache/xc_ini.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_sandbox.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h $(XCACHE_PROC_H)
-mod_coverager/xc_coverager.lo $(builddir)/mod_coverager/xc_coverager.lo: $(srcdir)/mod_coverager/xc_coverager.h $(srcdir)/util/xc_stack.h $(srcdir)/util/xc_trace.h $(srcdir)/xcache_globals.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_extension.h $(srcdir)/xcache/xc_ini.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h
+mod_cacher/xc_cacher.lo $(builddir)/mod_cacher/xc_cacher.lo: $(XCACHE_PROC_H) $(srcdir)/mod_cacher/xc_cache.h $(srcdir)/mod_cacher/xc_cacher.h $(srcdir)/util/xc_align.h $(srcdir)/util/xc_stack.h $(srcdir)/util/xc_trace.h $(srcdir)/util/xc_vector.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_extension.h $(srcdir)/xcache/xc_ini.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_sandbox.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h $(srcdir)/xcache_globals.h
+mod_coverager/xc_coverager.lo $(builddir)/mod_coverager/xc_coverager.lo: $(srcdir)/mod_coverager/xc_coverager.h $(srcdir)/util/xc_stack.h $(srcdir)/util/xc_trace.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_extension.h $(srcdir)/xcache/xc_ini.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h $(srcdir)/xcache_globals.h
 mod_decoder/xc_decoder.lo $(builddir)/mod_decoder/xc_decoder.lo:
-mod_disassembler/xc_disassembler.lo $(builddir)/mod_disassembler/xc_disassembler.lo: $(srcdir)/mod_disassembler/xc_disassembler.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_ini.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_sandbox.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h $(XCACHE_PROC_H)
+mod_disassembler/xc_disassembler.lo $(builddir)/mod_disassembler/xc_disassembler.lo: $(XCACHE_PROC_H) $(srcdir)/mod_disassembler/xc_disassembler.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_ini.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_sandbox.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h
 mod_encoder/xc_encoder.lo $(builddir)/mod_encoder/xc_encoder.lo:
-mod_optimizer/xc_optimizer.lo $(builddir)/mod_optimizer/xc_optimizer.lo: $(srcdir)/mod_optimizer/xc_optimizer.h $(srcdir)/util/xc_stack.h $(srcdir)/util/xc_trace.h $(srcdir)/xcache_globals.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_const_string.h $(srcdir)/xcache/xc_extension.h $(srcdir)/xcache/xc_ini.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_opcode_spec.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h $(XCACHE_PROC_H)
+mod_optimizer/xc_optimizer.lo $(builddir)/mod_optimizer/xc_optimizer.lo: $(XCACHE_PROC_H) $(srcdir)/mod_optimizer/xc_optimizer.h $(srcdir)/util/xc_stack.h $(srcdir)/util/xc_trace.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_const_string.h $(srcdir)/xcache/xc_extension.h $(srcdir)/xcache/xc_ini.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_opcode_spec.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h $(srcdir)/xcache_globals.h
 util/xc_stack.lo $(builddir)/util/xc_stack.lo: $(srcdir)/util/xc_stack.h $(srcdir)/util/xc_trace.h
 util/xc_trace.lo $(builddir)/util/xc_trace.lo: $(srcdir)/util/xc_trace.h
-xcache.lo $(builddir)/xcache.lo: $(srcdir)/util/xc_foreachcoresig.h $(srcdir)/util/xc_stack.h $(srcdir)/xcache_globals.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_const_string.h $(srcdir)/xcache/xc_extension.h $(srcdir)/xcache/xc_ini.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_opcode_spec.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h $(XCACHE_PROC_H)
+xcache.lo $(builddir)/xcache.lo: $(XCACHE_PROC_H) $(srcdir)/util/xc_foreachcoresig.h $(srcdir)/util/xc_stack.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_const_string.h $(srcdir)/xcache/xc_extension.h $(srcdir)/xcache/xc_ini.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_opcode_spec.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h $(srcdir)/xcache_globals.h
+xcache/xc_allocator.lo $(builddir)/xcache/xc_allocator.lo: $(srcdir)/xcache.h $(srcdir)/xcache/xc_allocator.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_shm.h
 xcache/xc_allocator_bestfit.lo $(builddir)/xcache/xc_allocator_bestfit.lo: $(srcdir)/util/xc_align.h $(srcdir)/util/xc_trace.h $(srcdir)/xcache/xc_allocator.h $(srcdir)/xcache/xc_shm.h
-xcache/xc_allocator.lo $(builddir)/xcache/xc_allocator.lo: $(srcdir)/xcache/xc_allocator.h $(srcdir)/xcache/xc_shm.h
 xcache/xc_compatibility.lo $(builddir)/xcache/xc_compatibility.lo: $(srcdir)/xcache/xc_compatibility.h
 xcache/xc_const_string.lo $(builddir)/xcache/xc_const_string.lo: $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_const_string.h $(srcdir)/xcache/xc_const_string_opcodes_php4.x.h $(srcdir)/xcache/xc_const_string_opcodes_php5.0.h $(srcdir)/xcache/xc_const_string_opcodes_php5.1.h $(srcdir)/xcache/xc_const_string_opcodes_php5.2.h $(srcdir)/xcache/xc_const_string_opcodes_php5.3.h $(srcdir)/xcache/xc_const_string_opcodes_php5.4.h $(srcdir)/xcache/xc_const_string_opcodes_php5.5.h $(srcdir)/xcache/xc_const_string_opcodes_php6.x.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_shm.h
 xcache/xc_extension.lo $(builddir)/xcache/xc_extension.lo: $(srcdir)/util/xc_stack.h $(srcdir)/util/xc_trace.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_extension.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_shm.h
 xcache/xc_ini.lo $(builddir)/xcache/xc_ini.lo: $(srcdir)/xcache/xc_ini.h
 xcache/xc_malloc.lo $(builddir)/xcache/xc_malloc.lo: $(srcdir)/util/xc_align.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_allocator.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_shm.h
 xcache/xc_mutex.lo $(builddir)/xcache/xc_mutex.lo: $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_shm.h
-xcache/xc_opcode_spec.lo $(builddir)/xcache/xc_opcode_spec.lo: $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_const_string.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_opcode_spec_def.h $(srcdir)/xcache/xc_opcode_spec.h $(srcdir)/xcache/xc_shm.h
+xcache/xc_opcode_spec.lo $(builddir)/xcache/xc_opcode_spec.lo: $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_const_string.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_opcode_spec.h $(srcdir)/xcache/xc_opcode_spec_def.h $(srcdir)/xcache/xc_shm.h
 xcache/xc_processor.lo $(builddir)/xcache/xc_processor.lo: $(XCACHE_PROC_C)
-xcache/xc_sandbox.lo $(builddir)/xcache/xc_sandbox.lo: $(srcdir)/util/xc_stack.h $(srcdir)/xcache_globals.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_sandbox.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h
-xcache/xc_shm.lo $(builddir)/xcache/xc_shm.lo: $(srcdir)/xcache/xc_shm.h
+xcache/xc_sandbox.lo $(builddir)/xcache/xc_sandbox.lo: $(srcdir)/util/xc_stack.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_sandbox.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h $(srcdir)/xcache_globals.h
+xcache/xc_shm.lo $(builddir)/xcache/xc_shm.lo: $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_shm.h
 xcache/xc_shm_mmap.lo $(builddir)/xcache/xc_shm_mmap.lo: $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h
-xcache/xc_utils.lo $(builddir)/xcache/xc_utils.lo: $(srcdir)/util/xc_stack.h $(srcdir)/util/xc_trace.h $(srcdir)/xcache_globals.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_opcode_spec.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h
+xcache/xc_utils.lo $(builddir)/xcache/xc_utils.lo: $(srcdir)/util/xc_stack.h $(srcdir)/util/xc_trace.h $(srcdir)/xcache.h $(srcdir)/xcache/xc_compatibility.h $(srcdir)/xcache/xc_mutex.h $(srcdir)/xcache/xc_opcode_spec.h $(srcdir)/xcache/xc_shm.h $(srcdir)/xcache/xc_utils.h $(srcdir)/xcache_globals.h
--- xcache.orig/NEWS
+++ xcache/NEWS
@@ -1,3 +1,16 @@
+4.0.0 2014-??-??
+========
+ * api updates
+ * cache defragment, cache to disk
+ * PHP_5_6 support
+
+3.2.1 2013-??-??
+========
+
+3.1.1 2013-??-??
+========
+ * compatible with bcompiler
+
 3.1.0 2013-10-10
 ========
  * adds support for PHP_5_5
--- xcache.orig/config.m4
+++ xcache/config.m4
@@ -109,8 +109,6 @@ done
     M4="$M4 -B 102400"
   fi
   PHP_SUBST([M4])
-  XCACHE_BACKTICK="'"'`'"'"
-  PHP_SUBST([XCACHE_BACKTICK])
   AC_PATH_PROGS([GREP], [grep])
   PHP_SUBST([GREP])
   AC_PATH_PROGS([SED], [sed])
--- xcache.orig/config.w32
+++ xcache/config.w32
@@ -70,7 +70,6 @@ xc_cacher.c \
 			ERROR(apps[i] + " is currently required to build XCache");
 		}
 	}
-	DEFINE("XCACHE_BACKTICK", "`")
 	PATH_PROG("gawk", null, "XCACHE_AWK") || PATH_PROG("awk", null, "XCACHE_AWK");
 
 	// the cygwin indent is known broken on our output
@@ -134,8 +133,6 @@ xc_cacher.c \
 	frag = frag.replace(/ -o /g, " /Fo");
 	frag = frag.replace(/cp /g, "copy ");
 	frag = frag.replace(/mv /g, "move ");
-	frag = frag.replace(/ \|\| /g, "\r\n\tif errorlevel 1 ");
-	frag = frag.replace(/ && /g, "\r\n\tif not errorlevel 1 ");
 	if (indent == '') {
 		frag = frag.replace(/\| *\$\(XCACHE_INDENT\)/g, '');
 		frag = frag.replace(/\$\(XCACHE_INDENT\) *< */g, 'type ');
--- xcache.orig/xcache.c
+++ xcache/xcache.c
@@ -176,42 +176,19 @@ void xc_shutdown_globals(zend_xcache_glo
 }
 /* }}} */
 
-/* {{{ proto int xcache_get_refcount(mixed variable)
-   XCache internal uses only: Get reference count of variable */
-PHP_FUNCTION(xcache_get_refcount)
-{
-	zval *variable;
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &variable) == FAILURE) {
-		RETURN_NULL();
-	}
+#ifdef HAVE_XCACHE_DPRINT
+/* {{{ proto bool  xcache_dprint(mixed value)
+   Prints internal struct of an zval (debug only) */
+#include "xc_processor.h"
 
-	RETURN_LONG(Z_REFCOUNT(*variable));
-}
-/* }}} */
-/* {{{ proto bool xcache_get_isref(mixed variable)
-   XCache internal uses only: Check if variable data is marked referenced */
 #ifdef ZEND_BEGIN_ARG_INFO_EX
-ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_isref, 0, 0, 1)
-	ZEND_ARG_INFO(1, variable)
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_dprint, 0, 0, 1)
+	ZEND_ARG_INFO(0, value)
 ZEND_END_ARG_INFO()
 #else
-static unsigned char arginfo_xcache_get_isref[] = { 1, BYREF_FORCE };
+static unsigned char arginfo_xcache_dprint[] = { 1, BYREF_NONE };
 #endif
 
-PHP_FUNCTION(xcache_get_isref)
-{
-	zval *variable;
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &variable) == FAILURE) {
-		RETURN_NULL();
-	}
-
-	RETURN_BOOL(Z_ISREF(*variable) && Z_REFCOUNT(*variable) >= 3);
-}
-/* }}} */
-#ifdef HAVE_XCACHE_DPRINT
-/* {{{ proto bool  xcache_dprint(mixed value)
-   Prints variable (or value) internal struct (debug only) */
-#include "xc_processor.h"
 PHP_FUNCTION(xcache_dprint)
 {
 	zval *value;
@@ -223,38 +200,36 @@ PHP_FUNCTION(xcache_dprint)
 }
 /* }}} */
 #endif
+#ifdef HAVE_XCACHE_ASSEMBLER
 /* {{{ proto string xcache_asm(string filename)
  */
-#ifdef HAVE_XCACHE_ASSEMBLER
 PHP_FUNCTION(xcache_asm)
 {
 }
-#endif
 /* }}} */
+#endif
+#ifdef HAVE_XCACHE_ENCODER
 /* {{{ proto string xcache_encode(string filename)
    Encode php file into XCache opcode encoded format */
-#ifdef HAVE_XCACHE_ENCODER
 PHP_FUNCTION(xcache_encode)
 {
 }
-#endif
 /* }}} */
+#endif
+#ifdef HAVE_XCACHE_DECODER
 /* {{{ proto bool xcache_decode_file(string filename)
    Decode(load) opcode from XCache encoded format file */
-#ifdef HAVE_XCACHE_DECODER
 PHP_FUNCTION(xcache_decode_file)
 {
 }
-#endif
 /* }}} */
 /* {{{ proto bool xcache_decode_string(string data)
    Decode(load) opcode from XCache encoded format data */
-#ifdef HAVE_XCACHE_DECODER
 PHP_FUNCTION(xcache_decode_string)
 {
 }
-#endif
 /* }}} */
+#endif
 /* {{{ xc_call_getter */
 typedef const char *(xc_name_getter_t)(zend_uchar type);
 static void xc_call_getter(xc_name_getter_t getter, int count, INTERNAL_FUNCTION_PARAMETERS)
@@ -280,30 +255,70 @@ static void xc_call_getter(xc_name_gette
 }
 /* }}} */
 /* {{{ proto string xcache_get_op_type(int op_type) */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_op_type, 0, 0, 1)
+	ZEND_ARG_INFO(0, op_type)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get_op_type[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_get_op_type)
 {
 	xc_call_getter(xc_get_op_type, xc_get_op_type_count(), INTERNAL_FUNCTION_PARAM_PASSTHRU);
 }
 /* }}} */
 /* {{{ proto string xcache_get_data_type(int type) */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_data_type, 0, 0, 1)
+	ZEND_ARG_INFO(0, type)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get_data_type[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_get_data_type)
 {
 	xc_call_getter(xc_get_data_type, xc_get_data_type_count(), INTERNAL_FUNCTION_PARAM_PASSTHRU);
 }
 /* }}} */
 /* {{{ proto string xcache_get_opcode(int opcode) */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_opcode, 0, 0, 1)
+	ZEND_ARG_INFO(0, opcode)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get_opcode[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_get_opcode)
 {
 	xc_call_getter(xc_get_opcode, xc_get_opcode_count(), INTERNAL_FUNCTION_PARAM_PASSTHRU);
 }
 /* }}} */
 /* {{{ proto string xcache_get_op_spec(int op_type) */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_op_spec, 0, 0, 1)
+	ZEND_ARG_INFO(0, op_type)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get_op_spec[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_get_op_spec)
 {
 	xc_call_getter(xc_get_op_spec, xc_get_op_spec_count(), INTERNAL_FUNCTION_PARAM_PASSTHRU);
 }
 /* }}} */
 /* {{{ proto string xcache_get_opcode_spec(int opcode) */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_opcode_spec, 0, 0, 1)
+	ZEND_ARG_INFO(0, opcode)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get_opcode_spec[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_get_opcode_spec)
 {
 	long spec;
@@ -328,6 +343,14 @@ PHP_FUNCTION(xcache_get_opcode_spec)
 /* }}} */
 /* {{{ proto mixed xcache_get_special_value(zval value)
    XCache internal use only: For decompiler to get static value with type fixed */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_special_value, 0, 0, 1)
+	ZEND_ARG_INFO(0, value)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get_special_value[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_get_special_value)
 {
 	zval *value;
@@ -343,11 +366,19 @@ PHP_FUNCTION(xcache_get_special_value)
 		return_value->type = UNISW(IS_STRING, UG(unicode) ? IS_UNICODE : IS_STRING);
 		break;
 
+#ifdef IS_CONSTANT_ARRAY
 	case IS_CONSTANT_ARRAY:
 		*return_value = *value;
 		zval_copy_ctor(return_value);
 		return_value->type = IS_ARRAY;
 		break;
+#endif
+
+#ifdef IS_CONSTANT_AST
+	case IS_CONSTANT_AST:
+		RETURN_NULL();
+		break;
+#endif
 
 	default:
 		if ((Z_TYPE_P(value) & ~IS_CONSTANT_TYPE_MASK)) {
@@ -363,6 +394,14 @@ PHP_FUNCTION(xcache_get_special_value)
 /* }}} */
 /* {{{ proto int xcache_get_type(zval value)
    XCache internal use only for disassembler to get variable type in engine level */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_type, 0, 0, 1)
+	ZEND_ARG_INFO(0, value)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get_type[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_get_type)
 {
 	zval *value;
@@ -374,7 +413,14 @@ PHP_FUNCTION(xcache_get_type)
 	RETURN_LONG(Z_TYPE_P(value));
 }
 /* }}} */
-/* {{{ proto string xcache_coredump(int op_type) */
+/* {{{ proto string xcache_coredump() */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_coredump, 0, 0, 0)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_coredump[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_coredump)
 {
 	if (xc_test) {
@@ -388,6 +434,14 @@ PHP_FUNCTION(xcache_coredump)
 }
 /* }}} */
 /* {{{ proto string xcache_is_autoglobal(string name) */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_is_autoglobal, 0, 0, 1)
+	ZEND_ARG_INFO(0, name)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_is_autoglobal[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_is_autoglobal)
 {
 	zval *name;
@@ -405,9 +459,71 @@ PHP_FUNCTION(xcache_is_autoglobal)
 	RETURN_BOOL(zend_u_hash_exists(CG(auto_globals), UG(unicode), Z_STRVAL_P(name), Z_STRLEN_P(name) + 1));
 }
 /* }}} */
+/* {{{ proto int xcache_get_refcount(mixed &variable)
+   XCache internal uses only: Get reference count of referenced variable */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_refcount, 0, 0, 1)
+	ZEND_ARG_INFO(1, variable)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get_refcount[] = { 1, BYREF_FORCE };
+#endif
+
+PHP_FUNCTION(xcache_get_refcount)
+{
+	zval *variable;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &variable) == FAILURE) {
+		RETURN_NULL();
+	}
+
+	RETURN_LONG(Z_REFCOUNT(*variable) - 1);
+}
+/* }}} */
+/* {{{ proto int xcache_get_cowcount(mixed value)
+   XCache internal uses only: Get reference count of copy-on-write variable or data */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_cowcount, 0, 0, 1)
+	ZEND_ARG_INFO(0, variable)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get_cowcount[] = { 1, BYREF_NONE };
+#endif
+
+PHP_FUNCTION(xcache_get_cowcount)
+{
+	zval *variable;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &variable) == FAILURE) {
+		RETURN_NULL();
+	}
+
+	RETURN_LONG(Z_REFCOUNT(*variable) - 1);
+}
+/* }}} */
+/* {{{ proto bool xcache_get_isref(mixed variable)
+   XCache internal uses only: Check if variable data is marked referenced */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get_isref, 0, 0, 1)
+	ZEND_ARG_INFO(1, variable)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get_isref[] = { 1, BYREF_FORCE };
+#endif
+
+PHP_FUNCTION(xcache_get_isref)
+{
+	zval *variable;
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "z", &variable) == FAILURE) {
+		RETURN_NULL();
+	}
+
+	RETURN_BOOL(Z_ISREF(*variable) && Z_REFCOUNT(*variable) >= 3);
+}
+/* }}} */
 static zend_function_entry xcache_functions[] = /* {{{ */
 {
-	PHP_FE(xcache_coredump,          NULL)
+#ifdef HAVE_XCACHE_DPRINT
+	PHP_FE(xcache_dprint,            arginfo_xcache_dprint)
+#endif
 #ifdef HAVE_XCACHE_ASSEMBLER
 	PHP_FE(xcache_asm,               NULL)
 #endif
@@ -418,18 +534,17 @@ static zend_function_entry xcache_functi
 	PHP_FE(xcache_decode_file,       NULL)
 	PHP_FE(xcache_decode_string,     NULL)
 #endif
-	PHP_FE(xcache_get_special_value, NULL)
-	PHP_FE(xcache_get_type,          NULL)
-	PHP_FE(xcache_get_op_type,       NULL)
-	PHP_FE(xcache_get_data_type,     NULL)
-	PHP_FE(xcache_get_opcode,        NULL)
-	PHP_FE(xcache_get_opcode_spec,   NULL)
-	PHP_FE(xcache_is_autoglobal,     NULL)
-	PHP_FE(xcache_get_refcount,      NULL)
+	PHP_FE(xcache_get_special_value, arginfo_xcache_get_special_value)
+	PHP_FE(xcache_get_type,          arginfo_xcache_get_type)
+	PHP_FE(xcache_get_op_type,       arginfo_xcache_get_op_type)
+	PHP_FE(xcache_get_data_type,     arginfo_xcache_get_data_type)
+	PHP_FE(xcache_get_opcode,        arginfo_xcache_get_opcode)
+	PHP_FE(xcache_get_opcode_spec,   arginfo_xcache_get_opcode_spec)
+	PHP_FE(xcache_coredump,          arginfo_xcache_coredump)
+	PHP_FE(xcache_is_autoglobal,     arginfo_xcache_is_autoglobal)
+	PHP_FE(xcache_get_refcount,      arginfo_xcache_get_refcount)
+	PHP_FE(xcache_get_cowcount,      arginfo_xcache_get_cowcount)
 	PHP_FE(xcache_get_isref,         arginfo_xcache_get_isref)
-#ifdef HAVE_XCACHE_DPRINT
-	PHP_FE(xcache_dprint,            NULL)
-#endif
 	PHP_FE_END
 };
 /* }}} */
@@ -582,6 +697,20 @@ static void xcache_signal_handler(int si
 		xc_disable_on_crash = 0;
 		xc_cacher_disable();
 	}
+
+	if (0) {
+	}
+#define FOREACH_SIG(forsig) \
+	else if (sig == forsig) \
+		write(2, XCACHE_STRL("Program received signal " #forsig ", Segmentation fault\n"))
+
+#include "util/xc_foreachcoresig.h"
+#undef FOREACH_SIG
+
+	write(2, XCACHE_STRL("If core dump is enabled it can be found at "));
+	write(2, xc_coredump_dir, strlen(xc_coredump_dir));
+	write(2, XCACHE_STRL("\n"));
+
 	raise(sig);
 }
 /* }}} */
@@ -728,12 +857,9 @@ static int xc_zend_startup(zend_extensio
 
 	ext = (zend_extension *) zend_extensions.head->data;
 	if (strcmp(ext->name, XCACHE_NAME) != 0) {
-		zend_error(E_WARNING, "XCache failed to load itself as the before \"%s\". compatibility downgraded", ext->name);
+		zend_error(E_WARNING, "XCache failed to load itself to before zend_extension=\"%s\". compatibility downgraded", ext->name);
 	}
 
-	old_compile_file = zend_compile_file;
-	zend_compile_file = xc_check_initial_compile_file;
-
 	for (ext = (zend_extension *) zend_llist_get_first_ex(&zend_extensions, &lpos);
 			ext;
 			ext = (zend_extension *) zend_llist_get_next_ex(&zend_extensions, &lpos)) {
@@ -820,6 +946,9 @@ static PHP_MINIT_FUNCTION(xcache) /* {{{
 
 	/* must be the first */
 	xcache_zend_extension_add(&xc_zend_extension_entry, 1);
+	old_compile_file = zend_compile_file;
+	zend_compile_file = xc_check_initial_compile_file;
+
 #ifdef HAVE_XCACHE_OPTIMIZER
 	xc_optimizer_startup_module();
 #endif
--- xcache.orig/xcache.h
+++ xcache/xcache.h
@@ -2,7 +2,7 @@
 #define __XCACHE_H
 #define XCACHE_NAME       "XCache"
 #ifndef XCACHE_VERSION
-#	define XCACHE_VERSION "3.1.0"
+#	define XCACHE_VERSION "4.0.0-dev"
 #endif
 #define XCACHE_AUTHOR     "mOo"
 #define XCACHE_COPYRIGHT  "Copyright (c) 2005-2013"
--- /dev/null
+++ xcache/processor/foot.m4
@@ -0,0 +1,170 @@
+dnl {{{ xc_store_target
+EXPORT(`typedef void *(*xc_processor_storage_allocator_t)(void *data, size_t size);')
+EXPORT(`typedef struct { xc_processor_storage_allocator_t allocator; void *allocator_data; ptrdiff_t relocatediff; } xc_processor_storage_t;')
+dnl }}}
+define(`DEFINE_STORE_API', `
+EXPORTED_FUNCTION(`$1 *xc_processor_store_$1(const xc_processor_storage_t *storage, $1 *src TSRMLS_DC)') dnl {{{
+{
+	$1 *dst;
+	xc_processor_t processor;
+
+	memset(&processor, 0, sizeof(processor));
+	processor.handle_reference = 1;
+	processor.relocatediff = storage->relocatediff;
+
+	IFAUTOCHECK(`xc_stack_init(&processor.allocsizes);')
+
+	/* calc size */ {
+		zend_hash_init(&processor.strings, 0, NULL, NULL, 0);
+		if (processor.handle_reference) {
+			zend_hash_init(&processor.zvalptrs, 0, NULL, NULL, 0);
+		}
+
+		processor.size = 0;
+		/* allocate */
+		processor.size = ALIGN(processor.size + sizeof(src[0]));
+
+		xc_calc_$1(&processor, src TSRMLS_CC);
+		if (processor.handle_reference) {
+			zend_hash_destroy(&processor.zvalptrs);
+		}
+		zend_hash_destroy(&processor.strings);
+	}
+	ifelse(
+		`$1', `xc_entry_data_php_t', `SRC(`size')',
+		`', `', SRC(`entry.size')) = processor.size;
+	ifelse(
+		`$1', `xc_entry_var_t', `SRC(`have_references') = processor.have_references;',
+		`$1', `xc_entry_data_php_t', `SRC(`have_references') = processor.have_references;'
+	)
+
+	IFAUTOCHECK(`xc_stack_reverse(&processor.allocsizes);')
+	/* store {{{ */
+	{
+		IFAUTOCHECK(`char *oldp;')
+		zend_hash_init(&processor.strings, 0, NULL, NULL, 0);
+		if (processor.handle_reference) {
+			zend_hash_init(&processor.zvalptrs, 0, NULL, NULL, 0);
+		}
+
+		/* allocator :) */
+		processor.p = (char *) storage->allocator(storage->allocator_data, processor.size);
+		if (processor.p == NULL) {
+			dst = NULL;
+			goto err_alloc;
+		}
+		IFAUTOCHECK(`oldp = processor.p;')
+		assert(processor.p == (char *) ALIGN(processor.p));
+
+		/* allocate */
+		dst = ($1 *) processor.p;
+		processor.p = (char *) ALIGN(processor.p + sizeof(dst[0]));
+
+		xc_store_$1(&processor, dst, src TSRMLS_CC);
+		IFAUTOCHECK(` {
+			size_t unexpected = processor.p - oldp;
+			size_t expected = processor.size;
+			if (unexpected != processor.size) {
+				fprintf(stderr, "unexpected:%lu - expected:%lu = %ld != 0\n", (unsigned long) unexpected, (unsigned long) expected, (long) unexpected - expected);
+				abort();
+			}
+		}')
+err_alloc:
+		if (processor.handle_reference) {
+			zend_hash_destroy(&processor.zvalptrs);
+		}
+		zend_hash_destroy(&processor.strings);
+	}
+	/* }}} */
+
+	IFAUTOCHECK(`xc_stack_destroy(&processor.allocsizes);')
+
+	return dst;
+}
+dnl }}}
+')
+DEFINE_STORE_API(`xc_entry_var_t')
+DEFINE_STORE_API(`xc_entry_php_t')
+DEFINE_STORE_API(`xc_entry_data_php_t')
+EXPORTED_FUNCTION(`xc_entry_php_t *xc_processor_restore_xc_entry_php_t(xc_entry_php_t *dst, const xc_entry_php_t *src TSRMLS_DC)') dnl {{{
+{
+	xc_processor_t processor;
+
+	memset(&processor, 0, sizeof(processor));
+	xc_restore_xc_entry_php_t(&processor, dst, src TSRMLS_CC);
+
+	return dst;
+}
+dnl }}}
+EXPORTED_FUNCTION(`xc_entry_data_php_t *xc_processor_restore_xc_entry_data_php_t(const xc_entry_php_t *entry_php, xc_entry_data_php_t *dst, const xc_entry_data_php_t *src, zend_bool readonly_protection TSRMLS_DC)') dnl {{{
+{
+	xc_processor_t processor;
+
+	memset(&processor, 0, sizeof(processor));
+	processor.readonly_protection = readonly_protection;
+	/* this function is used for php data only */
+	if (SRC(`have_references')) {
+		processor.handle_reference = 1;
+	}
+	processor.entry_php_src = entry_php;
+
+	if (processor.handle_reference) {
+		zend_hash_init(&processor.zvalptrs, 0, NULL, NULL, 0);
+	}
+	xc_restore_xc_entry_data_php_t(&processor, dst, src TSRMLS_CC);
+	if (processor.handle_reference) {
+		zend_hash_destroy(&processor.zvalptrs);
+	}
+	return dst;
+}
+dnl }}}
+EXPORTED_FUNCTION(`zval *xc_processor_restore_zval(zval *dst, const zval *src, zend_bool have_references TSRMLS_DC)') dnl {{{
+{
+	xc_processor_t processor;
+
+	memset(&processor, 0, sizeof(processor));
+	processor.handle_reference = have_references;
+
+	if (processor.handle_reference) {
+		zend_hash_init(&processor.zvalptrs, 0, NULL, NULL, 0);
+		dnl fprintf(stderr, "mark[%p] = %p\n", src, dst);
+		zend_hash_add(&processor.zvalptrs, (char *)src, sizeof(src), (void*)&dst, sizeof(dst), NULL);
+	}
+	xc_restore_zval(&processor, dst, src TSRMLS_CC);
+	if (processor.handle_reference) {
+		zend_hash_destroy(&processor.zvalptrs);
+	}
+
+	return dst;
+}
+dnl }}}
+define(`DEFINE_RELOCATE_API', `
+/* src = readable element, before memcpy if any
+ * dst = writable element, after memcpy if any
+ * virtual_src = brother pointers relatived to this address, before relocation
+ * virtual_dst = brother pointers relatived to this address, after  relocation
+ */
+EXPORTED_FUNCTION(`void xc_processor_relocate_$1($1 *dst, $1 *virtual_dst, $1 *src, $1 *virtual_src TSRMLS_DC)') dnl {{{
+{
+	char *old_address = 0; /* unkown X used later */
+	ptrdiff_t offset = ptrsub(old_address, (ptrdiff_t) virtual_src);
+
+	/* diff to new_ptr */
+	ptrdiff_t ptrdiff = ptrsub(dst, virtual_src);
+	ptrdiff_t relocatediff = (ptrdiff_t) ptradd($1 *, virtual_dst, offset);
+
+	xc_relocate_$1(dst, ptrdiff, relocatediff TSRMLS_CC);
+}
+dnl }}}
+')
+DEFINE_RELOCATE_API(`xc_entry_var_t')
+DEFINE_RELOCATE_API(`xc_entry_php_t')
+DEFINE_RELOCATE_API(`xc_entry_data_php_t')
+EXPORTED(`#ifdef HAVE_XCACHE_DPRINT')
+EXPORTED_FUNCTION(`void xc_dprint(xc_entry_php_t *src, int indent TSRMLS_DC)') dnl {{{
+{
+	IFDPRINT(`INDENT()`'fprintf(stderr, "xc_entry_php_t:src");')
+	xc_dprint_xc_entry_php_t(src, indent TSRMLS_CC);
+}
+dnl }}}
+EXPORTED(`#endif')
--- xcache.orig/processor/hashtable.m4
+++ xcache/processor/hashtable.m4
@@ -1,130 +1,103 @@
-dnl DEF_HASH_TABLE_FUNC(1:name, 2:datatype [, 3:dataname] [, 4:check_function])
-define(`DEF_HASH_TABLE_FUNC', `
-	DEF_STRUCT_P_FUNC(`HashTable', `$1', `
-		pushdefFUNC_NAME(`$2', `$3')
-		dnl {{{ dasm
-		IFDASM(`
-			const Bucket *srcBucket;
-			zval *zv;
-			int bufsize = 2;
-			char *buf = emalloc(bufsize);
-			int keysize;
+dnl DEF_HASH_TABLE_FUNC(1:name, 2:datatype [, 3:dataname])
+define(`DEF_HASH_TABLE_FUNC', `DEF_STRUCT_P_FUNC(`HashTable', `$1', `
+	pushdefFUNC_NAME(`$2', `$3')
+	dnl {{{ dasm
+	IFDASM(`
+		const Bucket *srcBucket;
+		zval *zv;
+		int bufsize = 2;
+		char *buf = emalloc(bufsize);
+		int keysize;
 
-#if defined(HARDENING_PATCH_HASH_PROTECT) && HARDENING_PATCH_HASH_PROTECT
-			DONE(canary)
-#endif
-			DONE(nTableSize)
-			DONE(nTableMask)
-			DONE(nNumOfElements)
-			DONE(nNextFreeElement)
-			DONE(pInternalPointer)
-			DONE(pListHead)
-			DONE(pListTail)
-			DONE(arBuckets)
-			DONE(pDestructor)
-			DONE(persistent)
-			DONE(nApplyCount)
-			DONE(bApplyProtection)
-#if ZEND_DEBUG
-			DONE(inconsistent)
-#endif
-#ifdef IS_UNICODE
-			DONE(unicode)
-#endif
+		define(`AUTOCHECK_SKIP')
+		IFAUTOCHECK(`xc_autocheck_skip = 1;')
 
-			DISABLECHECK(`
-			for (srcBucket = SRC(`pListHead'); srcBucket != NULL; srcBucket = srcBucket->pListNext) {
-				ALLOC_INIT_ZVAL(zv);
-				array_init(zv);
-				FUNC_NAME (dasm, zv, (($2*)srcBucket->pData) TSRMLS_CC);
-				keysize = BUCKET_KEY_SIZE(srcBucket) + 2;
-				if (keysize > bufsize) {
-					do {
-						bufsize *= 2;
-					} while (keysize > bufsize);
-					buf = erealloc(buf, bufsize);
-				}
-				memcpy(buf, BUCKET_KEY_S(srcBucket), keysize);
-				buf[keysize - 2] = buf[keysize - 1] = ""[0];
-				keysize = srcBucket->nKeyLength;
+		DISABLECHECK(`
+		for (srcBucket = SRC(`pListHead'); srcBucket != NULL; srcBucket = srcBucket->pListNext) {
+			ALLOC_INIT_ZVAL(zv);
+			array_init(zv);
+			FUNC_NAME (dasm, zv, (($2*)srcBucket->pData) TSRMLS_CC);
+			keysize = BUCKET_KEY_SIZE(srcBucket) + 2;
+			if (keysize > bufsize) {
+				do {
+					bufsize *= 2;
+				} while (keysize > bufsize);
+				buf = erealloc(buf, bufsize);
+			}
+			memcpy(buf, BUCKET_KEY_S(srcBucket), keysize);
+			buf[keysize - 2] = buf[keysize - 1] = ""[0];
+			keysize = srcBucket->nKeyLength;
 #ifdef IS_UNICODE
-				if (BUCKET_KEY_TYPE(srcBucket) == IS_UNICODE) {
-					if (buf[0] == ""[0] && buf[1] == ""[0]) {
-						keysize ++;
-					}
-				} else
-#endif
-				{
-					if (buf[0] == ""[0]) {
-						keysize ++;
-					}
+			if (BUCKET_KEY_TYPE(srcBucket) == IS_UNICODE) {
+				if (buf[0] == ""[0] && buf[1] == ""[0]) {
+					keysize ++;
+				}
+			} else
+#endif
+			{
+				if (buf[0] == ""[0]) {
+					keysize ++;
 				}
-				add_u_assoc_zval_ex(dst, BUCKET_KEY_TYPE(srcBucket), ZSTR(buf), keysize, zv);
 			}
-			')
+			add_u_assoc_zval_ex(dst, BUCKET_KEY_TYPE(srcBucket), ZSTR(buf), keysize, zv);
+		}
+		')
 
-			efree(buf);
-		', `
-		dnl }}}
-		Bucket *srcBucket;
-		IFCOPY(`Bucket *pnew = NULL, *prev = NULL;')
-		zend_bool first = 1;
-		dnl only used for copy
-		IFCOPY(`uint n;')
-		IFCALCCOPY(`size_t bucketsize;')
+		efree(buf);
+	', ` dnl IFDASM else
+	dnl }}}
+	Bucket *srcBucket;
+	IFCOPY(`Bucket *first = NULL, *last = NULL;')
+	IFRELOCATE(`Bucket *dstBucket = NULL;')
+	IFRESTORE(`Bucket *dstBucket = NULL;')
+	IFRELOCATE(`uint n;')
+	IFRESTORE(`uint n;')
+	IFCALCCOPY(`size_t bucketSize;')
 
 #if defined(HARDENING_PATCH_HASH_PROTECT) && HARDENING_PATCH_HASH_PROTECT
-		IFRESTORE(`DST(`canary') = zend_hash_canary; DONE(canary)', `
-			dnl else
-			PROCESS(unsigned int, canary)
-		')
+	IFRESTORE(`
+		DST(`canary') = zend_hash_canary;
+		DONE(canary)
+	', `
+		PROCESS(unsigned int, canary)
+	')
 #endif
-		PROCESS(uint, nTableSize)
-		PROCESS(uint, nTableMask)
-		PROCESS(uint, nNumOfElements)
-		PROCESS(ulong, nNextFreeElement)
-		IFCOPY(`DST(`pInternalPointer') = NULL;	/* Used for element traversal */') DONE(pInternalPointer)
-		IFCOPY(`DST(`pListHead') = NULL;') DONE(pListHead)
+	PROCESS(uint, nTableSize)
+	PROCESS(uint, nTableMask)
+	PROCESS(uint, nNumOfElements)
+	PROCESS(ulong, nNextFreeElement)
+	IFCOPY(`DST(`pInternalPointer') = NULL;	/* Used for element traversal */') DONE(pInternalPointer)
 #ifdef ZEND_ENGINE_2_4
 	if (SRC(`nTableMask')) {
 #endif
 		CALLOC(`DST(`arBuckets')', Bucket*, SRC(`nTableSize'))
 		DONE(arBuckets)
 		DISABLECHECK(`
-		for (srcBucket = SRC(`pListHead'); srcBucket != NULL; srcBucket = srcBucket->pListNext) {
-			ifelse($4, `', `', `
-				pushdef(`BUCKET', `srcBucket')
-				if ($4 == ZEND_HASH_APPLY_REMOVE) {
-					IFCOPY(`DST(`nNumOfElements') --;')
-					continue;
-				}
-				popdef(`BUCKET')
-			')
-
-			IFCALCCOPY(`bucketsize = BUCKET_SIZE(srcBucket);')
-			ALLOC(pnew, char, bucketsize, , Bucket)
+		for (srcBucket = PTR_FROM_VIRTUAL_EX(`Bucket', SRC(`pListHead')); srcBucket != NULL; srcBucket = PTR_FROM_VIRTUAL_EX(`Bucket', `srcBucket->pListNext')) {
+			IFCALCCOPY(`bucketSize = BUCKET_SIZE(srcBucket);')
+			ALLOC(dstBucket, char, bucketSize, , Bucket)
 			IFCOPY(`
 #ifdef ZEND_ENGINE_2_4
-				memcpy(pnew, srcBucket, BUCKET_HEAD_SIZE(Bucket));
+				memcpy(dstBucket, srcBucket, BUCKET_HEAD_SIZE(Bucket));
 				if (BUCKET_KEY_SIZE(srcBucket)) {
-					memcpy((char *) (pnew + 1), srcBucket->arKey, BUCKET_KEY_SIZE(srcBucket));
-					pnew->arKey = (const char *) (pnew + 1);
+					memcpy((char *) (dstBucket + 1), srcBucket->arKey, BUCKET_KEY_SIZE(srcBucket));
+					dstBucket->arKey = (const char *) (dstBucket + 1);
 				}
 				else {
-					pnew->arKey = NULL;
+					dstBucket->arKey = NULL;
 				}
 #else
-				memcpy(pnew, srcBucket, bucketsize);
+				memcpy(dstBucket, srcBucket, bucketSize);
 #endif
 				n = srcBucket->h & SRC(`nTableMask');
-				/* pnew into hash node chain */
-				pnew->pLast = NULL;
-				pnew->pNext = DST(`arBuckets[n]');
-				if (pnew->pNext) {
-					pnew->pNext->pLast = pnew;
+				/* dstBucket into hash node chain */
+				dstBucket->pLast = NULL;
+				dstBucket->pNext = DST(`arBuckets[n]');
+				if (dstBucket->pNext) {
+					dstBucket->pNext->pLast = dstBucket;
 				}
-				DST(`arBuckets[n]') = pnew;
 			')
+
 			IFDPRINT(`
 				INDENT()
 				fprintf(stderr, "$2:\"");
@@ -132,51 +105,90 @@ define(`DEF_HASH_TABLE_FUNC', `
 				fprintf(stderr, "\" %d:h=%lu ", BUCKET_KEY_SIZE(srcBucket), srcBucket->h);
 			')
 			if (sizeof(void *) == sizeof($2)) {
-				IFCOPY(`pnew->pData = &pnew->pDataPtr;')
-				dnl no alloc
-				STRUCT_P_EX(`$2', pnew->pData, (($2*)srcBucket->pData), `', `$3', ` ')
+				IFCOPY(`dstBucket->pData = &dstBucket->pDataPtr;')
+				IFRELOCATE(`srcBucket->pData = &srcBucket->pDataPtr;')
+				dnl $6 = ` ' to skip alloc, skip pointer fix
+				STRUCT_P_EX(`$2', dstBucket->pData, (($2*)srcBucket->pData), `', `$3', ` ')
+				RELOCATE_EX(`$2', dstBucket->pData)
 			}
 			else {
-				STRUCT_P_EX(`$2', pnew->pData, (($2*)srcBucket->pData), `', `$3')
-				IFCOPY(`pnew->pDataPtr = NULL;')
-			}
-
-			if (first) {
-				IFCOPY(`DST(`pListHead') = pnew;')
-				first = 0;
+				STRUCT_P_EX(`$2', dstBucket->pData, (($2*)srcBucket->pData), `', `$3')
+				IFCOPY(`dstBucket->pDataPtr = NULL;')
 			}
 
 			IFCOPY(`
+				if (!first) {
+					first = dstBucket;
+				}
+
 				/* flat link */
-				pnew->pListLast = prev;
-				pnew->pListNext = NULL;
-				if (prev) {
-					prev->pListNext = pnew;
+				dstBucket->pListLast = last;
+				dstBucket->pListNext = NULL;
+				if (last) {
+					last->pListNext = dstBucket;
 				}
-				prev = pnew;
+				last = dstBucket;
+
+				n = srcBucket->h & SRC(`nTableMask');
+				/* dstBucket into hash node chain */
+				dstBucket->pLast = NULL;
+				dstBucket->pNext = DST(`arBuckets[n]');
+				if (dstBucket->pNext) {
+					dstBucket->pNext->pLast = dstBucket;
+				}
+				DST(`arBuckets[n]') = dstBucket;
 			')
 		}
+		') dnl DISABLECHECK
+		IFCOPY(`DST(`pListHead') = first;') DONE(pListHead)
+		IFCOPY(`DST(`pListTail') = dstBucket;') DONE(pListTail)
+
+		IFRELOCATE(`
+		for (n = 0; n < SRC(`nTableSize'); ++n) {
+			if (SRC(`arBuckets[n]')) {
+				Bucket *next = PTR_FROM_VIRTUAL_EX(`Bucket', `DST(`arBuckets[n]')');
+				do {
+						dstBucket = next;
+						next = PTR_FROM_VIRTUAL_EX(`Bucket', `next->pNext');
+						if (dstBucket->pListLast) {
+							RELOCATE_EX(Bucket, dstBucket->pListLast)
+						}
+						if (dstBucket->pListNext) {
+							RELOCATE_EX(Bucket, dstBucket->pListNext)
+						}
+						if (dstBucket->pNext) {
+							RELOCATE_EX(Bucket, dstBucket->pNext)
+						}
+						if (dstBucket->pLast) {
+							RELOCATE_EX(Bucket, dstBucket->pLast)
+						}
+				} while (next);
+
+				RELOCATE(Bucket, arBuckets[n])
+			}
+		}
 		')
-		dnl TODO: fix pointer on arBuckets[n]
-		FIXPOINTER(Bucket *, arBuckets)
+		RELOCATE(Bucket, pListHead)
+		RELOCATE(Bucket, pListTail)
+		RELOCATE(Bucket *, arBuckets)
 #ifdef ZEND_ENGINE_2_4
 	}
 	else { /* if (SRC(`nTableMask')) */
+		IFCOPY(`DST(`pListHead') = NULL;') DONE(pListHead)
+		IFCOPY(`DST(`pListTail') = NULL;') DONE(pListTail)
 		DONE(arBuckets)
 	}
 #endif
-		IFCOPY(`DST(`pListTail') = pnew;') DONE(pListTail)
-		IFCOPY(`DST(`pDestructor') = SRC(`pDestructor');') DONE(pDestructor)
-		PROCESS(zend_bool, persistent)
+	IFCOPY(`DST(`pDestructor') = SRC(`pDestructor');') DONE(pDestructor)
+	PROCESS(zend_bool, persistent)
 #ifdef IS_UNICODE
-		PROCESS(zend_bool, unicode)
+	PROCESS(zend_bool, unicode)
 #endif
-		PROCESS(unsigned char, nApplyCount)
-		PROCESS(zend_bool, bApplyProtection)
+	PROCESS(unsigned char, nApplyCount)
+	PROCESS(zend_bool, bApplyProtection)
 #if ZEND_DEBUG
-		PROCESS(int, inconsistent)
+	PROCESS(int, inconsistent)
 #endif
-		')dnl IFDASM
-		popdef(`FUNC_NAME')
-	')
-')
+	')dnl IFDASM
+	popdef(`FUNC_NAME')
+')')
--- xcache.orig/processor/head.m4
+++ xcache/processor/head.m4
@@ -9,18 +9,15 @@ divert(0)
 #include "zend_API.h"
 #include "zend_ini.h"
 
-/* export: #include "xcache.h" :export */
-#include "xcache.h"
-/* export: #include "mod_cacher/xc_cache.h" :export */
-#include "mod_cacher/xc_cache.h"
-/* export: #include "xcache/xc_shm.h" :export */
-#include "xcache/xc_shm.h"
-/* export: #include "xcache/xc_allocator.h" :export */
-#include "xcache/xc_allocator.h"
+EXPORT(`#include <stddef.h>')
+EXPORT(`#include "xcache.h"')
+EXPORT(`#include "mod_cacher/xc_cache.h"')
+EXPORT(`#include "xcache/xc_shm.h"')
+EXPORT(`#include "xcache/xc_allocator.h"')
+#include "xc_processor.h"
 #include "xcache/xc_const_string.h"
 #include "xcache/xc_utils.h"
 #include "util/xc_align.h"
-#include "xc_processor.h"
 #include "xcache_globals.h"
 
 #if defined(HARDENING_PATCH_HASH_PROTECT) && HARDENING_PATCH_HASH_PROTECT
@@ -55,8 +52,6 @@ m4_errprint(`AUTOCHECK INFO: runtime aut
 ')
 ifdef(`DEBUG_SIZE', `static int xc_totalsize = 0;')
 
-sinclude(builddir`/structinfo.m4')
-
 #ifndef NDEBUG
 #	undef inline
 #define inline
@@ -84,21 +79,33 @@ typedef UChar zstr_uchar;
 typedef char  zstr_char;
 
 #define MAX_DUP_STR_LEN 256
+
+#define ptradd(type, ptr, ptrdiff) ((type) (((char *) (ptr)) + (ptrdiff)))
+#define ptrsub(ptr1, ptr2) (((char *) (ptr1)) - ((char *) (ptr2)))
+#ifdef NDEBUG
+	#define notnullable(ptr) (ptr)
+#else
+static inline void *notnullable(const void *ptr)
+{
+	assert(ptr);
+	return (void *) ptr;
+}
+#endif
 dnl }}}
-/* export: typedef struct _xc_processor_t xc_processor_t; :export {{{ */
-struct _xc_processor_t {
+dnl {{{ _xc_processor_t
+typedef struct _xc_processor_t {
 	char *p;
 	size_t size;
 	HashTable strings;
 	HashTable zvalptrs;
-	zend_bool reference; /* enable if to deal with reference */
+	zend_bool handle_reference; /* enable if to deal with reference */
 	zend_bool have_references;
+	ptrdiff_t relocatediff;
+
 	const xc_entry_php_t *entry_php_src;
 	const xc_entry_php_t *entry_php_dst;
 	const xc_entry_data_php_t *php_src;
 	const xc_entry_data_php_t *php_dst;
-	xc_shm_t                  *shm;
-	xc_allocator_t            *allocator;
 	const zend_class_entry *cache_ce;
 	zend_ulong cache_class_index;
 
@@ -112,10 +119,9 @@ struct _xc_processor_t {
 
 	zend_bool readonly_protection; /* wheather it's present */
 IFAUTOCHECK(xc_stack_t allocsizes;)
-};
-/* }}} */
-/* export: typedef struct _xc_dasm_t { const zend_op_array *active_op_array_src; } xc_dasm_t; :export {{{ */
-/* }}} */
+} xc_processor_t;
+dnl }}}
+EXPORT(`typedef struct _xc_dasm_t { const zend_op_array *active_op_array_src; } xc_dasm_t;')
 /* {{{ memsetptr */
 IFAUTOCHECK(`dnl
 static void *memsetptr(void *mem, void *content, size_t n)
@@ -157,21 +163,18 @@ static void xc_dprint_str_len(const char
 }
 /* }}} */
 #endif
-/* {{{ xc_zstrlen_char */
-static inline size_t xc_zstrlen_char(const_zstr s)
+static inline size_t xc_zstrlen_char(const_zstr s) /* {{{ */
 {
 	return strlen(ZSTR_S(s));
 }
 /* }}} */
 #ifdef IS_UNICODE
-/* {{{ xc_zstrlen_uchar */
-static inline size_t xc_zstrlen_uchar(zstr s)
+static inline size_t xc_zstrlen_uchar(zstr s) /* {{{ */
 {
 	return u_strlen(ZSTR_U(s));
 }
 /* }}} */
-/* {{{ xc_zstrlen */
-static inline size_t xc_zstrlen(int type, const_zstr s)
+static inline size_t xc_zstrlen(int type, const_zstr s) /* {{{ */
 {
 	return type == IS_UNICODE ? xc_zstrlen_uchar(s) : xc_zstrlen_char(s);
 }
@@ -181,15 +184,14 @@ static inline size_t xc_zstrlen(int type
 #define xc_zstrlen(dummy, s) xc_zstrlen_char(s)
 /* }}} */
 #endif
-/* {{{ xc_calc_string_n */
-REDEF(`PROCESSOR_TYPE', `calc')
 #undef C_RELAYLINE
 #define C_RELAYLINE
 IFAUTOCHECK(`
 #undef C_RELAYLINE
 #define C_RELAYLINE , __LINE__
 ')
-static inline void xc_calc_string_n(xc_processor_t *processor, zend_uchar type, const_zstr str, long size IFAUTOCHECK(`, int relayline')) {
+static inline void xc_calc_string_n(xc_processor_t *processor, zend_uchar type, const_zstr str, long size IFAUTOCHECK(`, int relayline')) { /* {{{ */
+	pushdef(`PROCESSOR_TYPE', `calc')
 	pushdef(`__LINE__', `relayline')
 	size_t realsize = UNISW(size, (type == IS_UNICODE) ? UBYTES(size) : size);
 	long dummy = 1;
@@ -207,11 +209,11 @@ static inline void xc_calc_string_n(xc_p
 		}
 	')
 	popdef(`__LINE__')
+	popdef(`PROCESSOR_TYPE')
 }
 /* }}} */
-/* {{{ xc_store_string_n */
-REDEF(`PROCESSOR_TYPE', `store')
-static inline zstr xc_store_string_n(xc_processor_t *processor, zend_uchar type, const_zstr str, long size IFAUTOCHECK(`, int relayline')) {
+static inline zstr xc_store_string_n(xc_processor_t *processor, zend_uchar type, const_zstr str, long size IFAUTOCHECK(`, int relayline')) { /* {{{ */
+	pushdef(`PROCESSOR_TYPE', `store')
 	pushdef(`__LINE__', `relayline')
 	size_t realsize = UNISW(size, (type == IS_UNICODE) ? UBYTES(size) : size);
 	zstr ret, *pret;
@@ -233,6 +235,7 @@ static inline zstr xc_store_string_n(xc_
 	return ret;
 
 	popdef(`__LINE__')
+	popdef(`PROCESSOR_TYPE')
 }
 /* }}} */
 /* {{{ xc_get_class_num
@@ -251,24 +254,25 @@ static zend_ulong xc_get_class_num(xc_pr
 		if (ZCEP_REFCOUNT_PTR(ceptr) == ZCEP_REFCOUNT_PTR(ce)) {
 			processor->cache_ce = ceptr;
 			processor->cache_class_index = i;
+			assert(i <= processor->active_class_index);
 			return i + 1;
 		}
 	}
 	assert(0);
 	return (zend_ulong) -1;
 }
-define(`xc_get_class_num', `xc_get_class_numNOTDEFINED')
+define(`xc_get_class_num', `IFSTORE(``xc_get_class_num'($@)',``xc_get_class_num' can be use in store only')')
 /* }}} */
-/* {{{ xc_get_class */
 #ifdef ZEND_ENGINE_2
-static zend_class_entry *xc_get_class(xc_processor_t *processor, zend_ulong class_num) {
+static zend_class_entry *xc_get_class(xc_processor_t *processor, zend_ulong class_num) { /* {{{ */
 	/* must be parent or currrent class */
+	assert(class_num > 0);
 	assert(class_num <= processor->active_class_index + 1);
 	return CestToCePtr(processor->php_dst->classinfos[class_num - 1].cest);
 }
-#endif
-define(`xc_get_class', `xc_get_classNOTDEFINED')
+define(`xc_get_class', `IFRESTORE(``xc_get_class'($@)',``xc_get_class' can be use in restore only')')
 /* }}} */
+#endif
 #ifdef ZEND_ENGINE_2
 /* fix method on store */
 static void xc_fix_method(xc_processor_t *processor, zend_op_array *dst TSRMLS_DC) /* {{{ */
@@ -396,159 +400,3 @@ static int xc_check_names(const char *fi
 }
 ')
 /* }}} */
-dnl ================ export API
-define(`DEFINE_STORE_API', `
-/* export: $1 *xc_processor_store_$1(xc_shm_t *shm, xc_allocator_t *allocator, $1 *src TSRMLS_DC); :export {{{ */
-$1 *xc_processor_store_$1(xc_shm_t *shm, xc_allocator_t *allocator, $1 *src TSRMLS_DC) {
-	$1 *dst;
-	xc_processor_t processor;
-
-	memset(&processor, 0, sizeof(processor));
-	processor.reference = 1;
-	processor.shm = shm;
-	processor.allocator = allocator;
-
-	IFAUTOCHECK(`xc_stack_init(&processor.allocsizes);')
-
-	/* calc size */ {
-		zend_hash_init(&processor.strings, 0, NULL, NULL, 0);
-		if (processor.reference) {
-			zend_hash_init(&processor.zvalptrs, 0, NULL, NULL, 0);
-		}
-
-		processor.size = 0;
-		/* allocate */
-		processor.size = ALIGN(processor.size + sizeof(src[0]));
-
-		xc_calc_$1(&processor, src TSRMLS_CC);
-		if (processor.reference) {
-			zend_hash_destroy(&processor.zvalptrs);
-		}
-		zend_hash_destroy(&processor.strings);
-	}
-	ifelse(
-		`$1', `xc_entry_data_php_t', `SRC(`size')',
-		`', `', SRC(`entry.size')) = processor.size;
-	ifelse(
-		`$1', `xc_entry_var_t', `SRC(`have_references') = processor.have_references;',
-		`$1', `xc_entry_data_php_t', `SRC(`have_references') = processor.have_references;'
-	)
-
-	IFAUTOCHECK(`xc_stack_reverse(&processor.allocsizes);')
-	/* store {{{ */
-	{
-		IFAUTOCHECK(`char *oldp;')
-		zend_hash_init(&processor.strings, 0, NULL, NULL, 0);
-		if (processor.reference) {
-			zend_hash_init(&processor.zvalptrs, 0, NULL, NULL, 0);
-		}
-
-		/* allocator :) */
-		processor.p = (char *) processor.allocator->vtable->malloc(processor.allocator, processor.size);
-		if (processor.p == NULL) {
-			dst = NULL;
-			goto err_alloc;
-		}
-		IFAUTOCHECK(`oldp = processor.p;')
-		assert(processor.p == (char *) ALIGN(processor.p));
-
-		/* allocate */
-		dst = ($1 *) processor.p;
-		processor.p = (char *) ALIGN(processor.p + sizeof(dst[0]));
-
-		xc_store_$1(&processor, dst, src TSRMLS_CC);
-		IFAUTOCHECK(` {
-			size_t unexpected = processor.p - oldp;
-			size_t expected = processor.size;
-			if (unexpected != processor.size) {
-				fprintf(stderr, "unexpected:%lu - expected:%lu = %ld != 0\n", (unsigned long) unexpected, (unsigned long) expected, (long) unexpected - expected);
-				abort();
-			}
-		}')
-err_alloc:
-		if (processor.reference) {
-			zend_hash_destroy(&processor.zvalptrs);
-		}
-		zend_hash_destroy(&processor.strings);
-	}
-	/* }}} */
-
-	IFAUTOCHECK(`xc_stack_destroy(&processor.allocsizes);')
-
-	return dst;
-}
-/* }}} */
-')
-DEFINE_STORE_API(`xc_entry_var_t')
-DEFINE_STORE_API(`xc_entry_php_t')
-DEFINE_STORE_API(`xc_entry_data_php_t')
-/* export: xc_entry_php_t *xc_processor_restore_xc_entry_php_t(xc_entry_php_t *dst, const xc_entry_php_t *src TSRMLS_DC); :export {{{ */
-xc_entry_php_t *xc_processor_restore_xc_entry_php_t(xc_entry_php_t *dst, const xc_entry_php_t *src TSRMLS_DC) {
-	xc_processor_t processor;
-
-	memset(&processor, 0, sizeof(processor));
-	xc_restore_xc_entry_php_t(&processor, dst, src TSRMLS_CC);
-
-	return dst;
-}
-/* }}} */
-/* export: xc_entry_data_php_t *xc_processor_restore_xc_entry_data_php_t(const xc_entry_php_t *entry_php, xc_entry_data_php_t *dst, const xc_entry_data_php_t *src, zend_bool readonly_protection TSRMLS_DC); :export {{{ */
-xc_entry_data_php_t *xc_processor_restore_xc_entry_data_php_t(const xc_entry_php_t *entry_php, xc_entry_data_php_t *dst, const xc_entry_data_php_t *src, zend_bool readonly_protection TSRMLS_DC) {
-	xc_processor_t processor;
-
-	memset(&processor, 0, sizeof(processor));
-	processor.readonly_protection = readonly_protection;
-	/* this function is used for php data only */
-	if (SRC(`have_references')) {
-		processor.reference = 1;
-	}
-	processor.entry_php_src = entry_php;
-
-	if (processor.reference) {
-		zend_hash_init(&processor.zvalptrs, 0, NULL, NULL, 0);
-	}
-	xc_restore_xc_entry_data_php_t(&processor, dst, src TSRMLS_CC);
-	if (processor.reference) {
-		zend_hash_destroy(&processor.zvalptrs);
-	}
-	return dst;
-}
-/* }}} */
-/* export: xc_entry_var_t *xc_processor_restore_xc_entry_var_t(xc_entry_var_t *dst, const xc_entry_var_t *src TSRMLS_DC); :export {{{ */
-xc_entry_var_t *xc_processor_restore_xc_entry_var_t(xc_entry_var_t *dst, const xc_entry_var_t *src TSRMLS_DC) {
-	xc_processor_t processor;
-
-	memset(&processor, 0, sizeof(processor));
-	xc_restore_xc_entry_var_t(&processor, dst, src TSRMLS_CC);
-
-	return dst;
-}
-/* }}} */
-/* export: zval *xc_processor_restore_zval(zval *dst, const zval *src, zend_bool have_references TSRMLS_DC); :export {{{ */
-zval *xc_processor_restore_zval(zval *dst, const zval *src, zend_bool have_references TSRMLS_DC) {
-	xc_processor_t processor;
-
-	memset(&processor, 0, sizeof(processor));
-	processor.reference = have_references;
-
-	if (processor.reference) {
-		zend_hash_init(&processor.zvalptrs, 0, NULL, NULL, 0);
-		dnl fprintf(stderr, "mark[%p] = %p\n", src, dst);
-		zend_hash_add(&processor.zvalptrs, (char *)src, sizeof(src), (void*)&dst, sizeof(dst), NULL);
-	}
-	xc_restore_zval(&processor, dst, src TSRMLS_CC);
-	if (processor.reference) {
-		zend_hash_destroy(&processor.zvalptrs);
-	}
-
-	return dst;
-}
-/* }}} */
-/* export: void xc_dprint(xc_entry_php_t *src, int indent TSRMLS_DC); :export {{{ */
-#ifdef HAVE_XCACHE_DPRINT
-void xc_dprint(xc_entry_php_t *src, int indent TSRMLS_DC) {
-	IFDPRINT(`INDENT()`'fprintf(stderr, "xc_entry_php_t:src");')
-	xc_dprint_xc_entry_php_t(src, indent TSRMLS_CC);
-}
-#endif
-/* }}} */
--- xcache.orig/processor/main.m4
+++ xcache/processor/main.m4
@@ -17,17 +17,28 @@ ifdef(`len', `
 define(`m4_len', defn(`len'))
 undefine(`len')
 ')
+define(`dirof', `patsubst(`$1', `[/\\][^/\\]*$', `')')
+ifdef(`__dir__', `', `
+define(`__dir__', `dirof(__file__)')
+')
 define(`XCACHE_STRS', `($1), (sizeof($1))')
 define(`XCACHE_STRL', `($1), (sizeof($1) - 1)')
-define(`DST', `dst->$1')
-define(`SRC', `src->$1')
+define(`SRC', `ifelse(`$1', `', `src', `src->$1')')
+define(`DST', `ifelse(`$1', `', `dst', `dst->$1')')
 dnl ============
 define(`INDENT', `xc_dprint_indent(indent);')
 dnl }}}
+dnl {{{ PTR_FROM_VIRTUAL_EX(1:type, 2:elm)
+define(`PTR_FROM_VIRTUAL_EX', `$2')
+dnl }}}
 dnl {{{ ALLOC(1:dst, 2:type, 3:count=1, 4:clean=false, 5:realtype=$2)
 define(`ALLOC', `
 	pushdef(`COUNT', `ifelse(`$3', `', `1', `$3')')
-	pushdef(`SIZE', `sizeof($2)ifelse(`$3', `', `', ` * $3')')
+	ifdef(`ALLOC_SIZE_HELPER', `
+		pushdef(`SIZE', `ALLOC_SIZE_HELPER()')
+	', `
+		pushdef(`SIZE', `sizeof($2)ifelse(`$3', `', `', ` * $3')')
+	')
 	pushdef(`REALTYPE', `ifelse(`$5', , `$2', `$5')')
 	/* allocate */
 	IFCALC(`
@@ -94,9 +105,9 @@ define(`PROC_CLASS_ENTRY_P_EX', `
 		IFSTORE(`$1 = (zend_class_entry *) xc_get_class_num(processor, $2);')
 		IFRESTORE(`$1 = xc_get_class(processor, (zend_ulong) $2);')
 #ifdef IS_UNICODE
-		IFDASM(`add_assoc_unicodel_ex(dst, XCACHE_STRS("$3"), ZSTR_U($2->name), $2->name_length, 1);')
+		IFDASM(`add_assoc_unicodel_ex(DST(), XCACHE_STRS("$3"), ZSTR_U($2->name), $2->name_length, 1);')
 #else
-		IFDASM(`add_assoc_stringl_ex(dst, XCACHE_STRS("$3"), (char *) $2->name, $2->name_length, 1);')
+		IFDASM(`add_assoc_stringl_ex(DST(), XCACHE_STRS("$3"), (char *) $2->name, $2->name_length, 1);')
 #endif
 	}
 	else {
@@ -119,23 +130,29 @@ define(`DBG', `ifdef(`XCACHE_ENABLE_TEST
 	/* `$1' */
 ')')
 dnl }}}
-dnl {{{ EXPORT
-define(`EXPORT', `define(`EXPORT_$1')')
+dnl {{{ EXPORT(1:code)
+define(`EXPORT', `/* export: $1 :export */')
+define(`EXPORTED', `EXPORT(`$1')
+$1')
+define(`EXPORTED_FUNCTION', `EXPORT(`$1;')
+$1')
+dnl }}}
+dnl {{{ EXPORT_PROCESSOR(1:type, 2:processor)
+define(`EXPORT_PROCESSOR', `define(`EXPORT_$1_$2', 1)')
 dnl }}}
-dnl {{{ FIXPOINTER
-define(`FIXPOINTER', `FIXPOINTER_EX(`$1', `DST(`$2')')')
-define(`FIXPOINTER_EX', `IFSTORE(`
-	$2 = ($1 *) processor->shm->handlers->to_readonly(processor->shm, (void *)$2);
-')')
-define(`UNFIXPOINTER', `UNFIXPOINTER_EX(`$1', `DST(`$2')')')
-define(`UNFIXPOINTER_EX', `IFSTORE(`
-	$2 = ($1 *) processor->shm->handlers->to_readwrite(processor->shm, (void *)$2);
-')')
+dnl {{{ RELOCATE(1:type, 2:ele)
+define(`RELOCATE', `RELOCATE_EX(`$1', `DST(`$2')')')
+dnl }}}
+dnl {{{ RELOCATE_EX(1:type, 2:dst)
+define(`RELOCATE_EX', `')
+dnl }}}
+dnl {{{ IFNOTMEMCPY
+define(`IFNOTMEMCPY', `ifdef(`USEMEMCPY', `', `$1')')
 dnl }}}
 dnl {{{ COPY
 define(`COPY', `IFNOTMEMCPY(`IFCOPY(`DST(`$1') = SRC(`$1');')')DONE(`$1')')
 dnl }}}
-dnl {{{ COPY_N_EX
+dnl {{{ COPY_N_EX(1:count, 2:type, 3:dst)
 define(`COPY_N_EX', `
 	ALLOC(`DST(`$3')', `$2', `SRC(`$1')')
 	IFCOPY(`
@@ -143,31 +160,18 @@ define(`COPY_N_EX', `
 		')
 ')
 dnl }}}
-dnl {{{ COPY_N
-define(`COPY_N', `COPY_N_EX(`$1',`$2')DONE(`$1')')
-dnl }}}
 dnl {{{ COPYPOINTER
 define(`COPYPOINTER', `COPY(`$1')')
 dnl }}}
-dnl {{{ COPYARRAY_EX
-define(`COPYARRAY_EX', `IFNOTMEMCPY(`IFCOPY(`memcpy(DST(`$1'), SRC(`$1'), sizeof(DST(`$1')));')')')
-dnl }}}
-dnl {{{ COPYARRAY
-define(`COPYARRAY', `COPYARRAY_EX(`$1',`$2')DONE(`$1')')
-dnl }}}
 dnl {{{ SETNULL_EX
 define(`SETNULL_EX', `IFCOPY(`$1 = NULL;')')
 define(`SETNULL', `SETNULL_EX(`DST(`$1')')DONE(`$1')')
 dnl }}}
-dnl {{{ SETZERO_EX
-define(`SETZERO_EX', `IFCOPY(`$1 = 0;')')
-define(`SETZERO', `SETZERO_EX(`DST(`$1')')DONE(`$1')')
-dnl }}}
 dnl {{{ COPYNULL_EX(1:dst, 2:elm-name)
 define(`COPYNULL_EX', `
-	IFDASM(`add_assoc_null_ex(dst, XCACHE_STRS("$2"));')
+	IFDASM(`add_assoc_null_ex(DST(), XCACHE_STRS("$2"));')
 	IFNOTMEMCPY(`IFCOPY(`$1 = NULL;')')
-	assert(patsubst($1, dst, src) == NULL);
+	assert(patsubst($1, DST(), SRC()) == NULL);
 ')
 dnl }}}
 dnl {{{ COPYNULL(1:elm)
@@ -177,9 +181,9 @@ define(`COPYNULL', `
 dnl }}}
 dnl {{{ COPYZERO_EX(1:dst, 2:elm-name)
 define(`COPYZERO_EX', `
-	IFDASM(`add_assoc_long_ex(dst, XCACHE_STRS("$2"), 0);')
+	IFDASM(`add_assoc_long_ex(DST(), XCACHE_STRS("$2"), 0);')
 	IFNOTMEMCPY(`IFCOPY(`$1 = 0;')')
-	assert(patsubst($1, dst, src) == 0);
+	assert(patsubst($1, DST(), SRC()) == 0);
 ')
 dnl }}}
 dnl {{{ COPYZERO(1:elm)
@@ -241,42 +245,59 @@ define(`IFCALCSTORE', `IFSTORE(`$1', `IF
 define(`IFRESTORE', `ifelse(PROCESSOR_TYPE, `restore', `$1', `$2')')
 define(`IFCOPY', `IFSTORE(`$1', `IFRESTORE(`$1', `$2')')')
 define(`IFCALCCOPY', `IFCALC(`$1', `IFCOPY(`$1', `$2')')')
+define(`PROCRELOCATE', `ifelse(PROCESSOR_TYPE, `relocate', `$1', `$2')')
+define(`IFRELOCATE', `ifelse(defn(`RELOCATE_EX'), `', `$2', `$1')')
 define(`IFDPRINT', `ifelse(PROCESSOR_TYPE, `dprint', `$1', `$2')')
 define(`IFDASM', `ifelse(PROCESSOR_TYPE, `dasm', `$1', `$2')')
 dnl }}}
-EXPORT(`zend_op')
-EXPORT(`zend_op_array')
-EXPORT(`zend_function')
-EXPORT(`HashTable_zend_function')
-EXPORT(`zend_class_entry')
-EXPORT(`xc_classinfo_t')
-EXPORT(`xc_funcinfo_t')
-EXPORT(`xc_entry_var_t')
-EXPORT(`xc_entry_php_t')
-EXPORT(`xc_entry_data_php_t')
-EXPORT(`zval')
-
-include(srcdir`/processor/hashtable.m4')
-include(srcdir`/processor/string.m4')
-include(srcdir`/processor/struct.m4')
-include(srcdir`/processor/process.m4')
-include(srcdir`/processor/head.m4')
 
-define(`IFNOTMEMCPY', `ifdef(`USEMEMCPY', `', `$1')')
-REDEF(`PROCESSOR_TYPE', `calc') include(srcdir`/processor/processor.m4')
-pushdef(`xc_get_class_num', ``xc_get_class_num'($@)')
-REDEF(`PROCESSOR_TYPE', `store') include(srcdir`/processor/processor.m4')
-popdef(`xc_get_class_num')
-pushdef(`xc_get_class', ``xc_get_class'($@)')
-REDEF(`PROCESSOR_TYPE', `restore') include(srcdir`/processor/processor.m4')
-popdef(`xc_get_class')
+EXPORT_PROCESSOR(`dasm',   `zend_op_array')
+EXPORT_PROCESSOR(`dasm',   `zend_function')
+EXPORT_PROCESSOR(`dasm',   `zend_class_entry')
+EXPORT_PROCESSOR(`dprint', `zval')
+
+include(__dir__`/hashtable.m4')
+include(__dir__`/string.m4')
+include(__dir__`/struct.m4')
+include(__dir__`/process.m4')
+include(__dir__`/head.m4')
+
+dnl ==== calc ====
+REDEF(`PROCESSOR_TYPE', `calc')
+include(__dir__`/processor.m4')
+
+dnl ==== store ====
+pushdef(`RELOCATE_EX', `$2 = ptradd($1 *, notnullable($2), processor->relocatediff);')
+REDEF(`PROCESSOR_TYPE', `store')
+include(__dir__`/processor.m4')
+popdef(`RELOCATE_EX')
 
-REDEF(`IFNOTMEMCPY', `$1')
+dnl ==== restore ====
+REDEF(`PROCESSOR_TYPE', `restore')
+include(__dir__`/processor.m4')
+
+dnl ==== relocate ====
+pushdef(`PTR_FROM_VIRTUAL_EX', `ptradd($1 *, notnullable($2), ptrdiff)')
+pushdef(`RELOCATE_EX', `$2 = ptradd($1 *, notnullable($2), relocatediff);')
+pushdef(`SRC', defn(`DST'))
+REDEF(`PROCESSOR_TYPE', `relocate')
+include(__dir__`/processor.m4')
+popdef(`SRC')
+popdef(`RELOCATE_EX')
+popdef(`PTR_FROM_VIRTUAL_EX')
+
+dnl ==== dprint ====
 #ifdef HAVE_XCACHE_DPRINT
-REDEF(`PROCESSOR_TYPE', `dprint') include(srcdir`/processor/processor.m4')
+REDEF(`PROCESSOR_TYPE', `dprint') include(__dir__`/processor.m4')
 #endif /* HAVE_XCACHE_DPRINT */
+
+dnl ==== dasm ====
 #ifdef HAVE_XCACHE_DISASSEMBLER
-REDEF(`PROCESSOR_TYPE', `dasm') include(srcdir`/processor/processor.m4')
+REDEF(`PROCESSOR_TYPE', `dasm') include(__dir__`/processor.m4')
 #endif /* HAVE_XCACHE_DISASSEMBLER */
 
+undefine(`PROCESSOR_TYPE')
+
+include(__dir__`/foot.m4')
+
 ifdef(`EXIT_PENDING', `m4exit(EXIT_PENDING)')
--- xcache.orig/processor/process.m4
+++ xcache/processor/process.m4
@@ -13,6 +13,9 @@ define(`PROCESS_SCALAR', `dnl {{{ (1:elm
 	DONE(`$1')
 ')
 dnl }}}
+dnl {{{ PROCESS_CTEXTPOINTER
+define(`PROCESS_CTEXTPOINTER', `COPY(`$1')')
+dnl }}}
 define(`PROCESS_xc_ztstring', `dnl {{{ (1:elm)
 	pushdef(`REALPTRTYPE', `zend_class_entry')
 	PROC_STRING(`$1')
@@ -71,7 +74,7 @@ define(`PROCESS', `dnl PROCESS(1:type, 2
 	, `$1', `xc_zval_type_t',    `PROCESS_xc_zval_type_t(`$2')'
 	, `$1', `xc_op_type',        `PROCESS_xc_op_type(`$2')'
 	, `$1', `xc_opcode',         `PROCESS_xc_opcode(`$2')'
-	, `$1', `opcode_handler_t',  `/* is copying enough? */COPY(`$2')'
+	, `$1', `opcode_handler_t',  `/* is copying enough? */PROCESS_CTEXTPOINTER(`$2')'
 	, `$1', `xc_md5sum_t',       `COPY(`$2')'
 	, `', `', `m4_errprint(`AUTOCHECK ERROR: Unknown type "$1"')define(`EXIT_PENDING', 1)'
 	)
@@ -89,7 +92,7 @@ define(`PROCESS_ARRAY', `dnl {{{ (1:coun
 					`', `', `LOOPCOUNTER < SRC(`$1')');
 					++LOOPCOUNTER) {
 				pushdef(`dst', `arr')
-				pushdef(`SRC', `ifelse(`$4', `', `', `', `', `($2)')' defn(`SRC') `[LOOPCOUNTER]')
+				pushdef(`SRC', `ifelse(`$4', `', `', `($2)')' defn(`SRC') `[LOOPCOUNTER]')
 				popdef(`add_assoc_bool_ex', `add_next_index_bool($1, $3)')
 				popdef(`add_assoc_string_ex', `add_next_index_string($1, $3)')
 				popdef(`add_assoc_long_ex', `add_next_index_long($1, $3)')
--- xcache.orig/processor/processor.m4
+++ xcache/processor/processor.m4
@@ -25,22 +25,22 @@ DEF_STRUCT_P_FUNC(`zend_compiled_variabl
 dnl }}}
 #endif
 DEF_STRUCT_P_FUNC(`zend_uint', , `dnl {{{
-	IFCOPY(`dst[0] = src[0];')
+	IFCOPY(`DST()[0] = SRC()[0];')
 	IFDPRINT(`
 		INDENT()
-		fprintf(stderr, "%u\n", src[0]);
+		fprintf(stderr, "%u\n", SRC()[0]);
 	')
-	DONE_SIZE(sizeof(src[0]))
+	DONE_SIZE(sizeof(SRC()[0]))
 ')
 dnl }}}
 #ifndef ZEND_ENGINE_2
 DEF_STRUCT_P_FUNC(`int', , `dnl {{{
-	IFCOPY(`*dst = *src;')
+	IFCOPY(`*DST() = *SRC();')
 	IFDPRINT(`
 		INDENT()
-		fprintf(stderr, "%d\n", src[0]);
+		fprintf(stderr, "%d\n", SRC()[0]);
 	')
-	DONE_SIZE(sizeof(src[0]))
+	DONE_SIZE(sizeof(SRC()[0]))
 ')
 dnl }}}
 #endif
@@ -69,12 +69,52 @@ DEF_HASH_TABLE_FUNC(`HashTable_zend_func
 #ifdef ZEND_ENGINE_2
 DEF_HASH_TABLE_FUNC(`HashTable_zend_property_info', `zend_property_info')
 #endif
+#ifdef IS_CONSTANT_AST
+define(`ZEND_AST_HELPER', `
+	{
+	IFCALCCOPY(`
+		size_t zend_ast_size = $1->kind == ZEND_CONST
+		 ? sizeof(zend_ast) + sizeof(zval)
+		 : sizeof(zend_ast) + sizeof(zend_ast *) * ($1->children - 1);
+	')
+
+	pushdef(`ALLOC_SIZE_HELPER', `zend_ast_size')
+	$2
+	popdef(`ALLOC_SIZE_HELPER')
+	}
+')
+DEF_STRUCT_P_FUNC(`zend_ast', , `dnl {{{
+		zend_ushort i;
+		PROCESS(zend_ushort, kind)
+		PROCESS(zend_ushort, children)
+		DONE(u)
+		DISABLECHECK(`
+			if (SRC()->kind == ZEND_CONST) {
+				assert(SRC()->u.val);
+				IFCOPY(`
+					memcpy(DST()->u.val, SRC()->u.val, sizeof(zval));
+				')
+				STRUCT_P_EX(zval, DST()->u.val, SRC()->u.val, `', `', ` ')
+				RELOCATE_EX(zval, DST()->u.val)
+			}
+			else {
+				for (i = 0; i < SRC()->children; ++i) {
+					zend_ast *src_ast = (&SRC()->u.child)[i];
+					ALLOC(`(&DST()->u.child)[i]', zend_ast)
+					ZEND_AST_HELPER(`src_ast', `STRUCT_P_EX(zend_ast, (&DST()->u.child)[i], src_ast, `[i]', `', ` ')')
+					RELOCATE_EX(zend_ast, (&DST()->u.child)[i])
+				}
+			}
+		')
+')
+dnl }}}
+#endif
 DEF_STRUCT_P_FUNC(`zval', , `dnl {{{
 	IFDASM(`do {
-		zval_dtor(dst);
-		*dst = *src;
-		zval_copy_ctor(dst);
-		Z_SET_REFCOUNT(*dst, 1);
+		zval_dtor(DST());
+		*DST() = *SRC();
+		zval_copy_ctor(DST());
+		Z_SET_REFCOUNT(*DST(), 1);
 		DONE(value)
 		DONE(type)
 #ifdef ZEND_ENGINE_2_3
@@ -90,7 +130,7 @@ DEF_STRUCT_P_FUNC(`zval', , `dnl {{{
 		/* Variable information */
 dnl {{{ zvalue_value
 		DISABLECHECK(`
-		switch ((Z_TYPE_P(src) & IS_CONSTANT_TYPE_MASK)) {
+		switch ((Z_TYPE_P(SRC()) & IS_CONSTANT_TYPE_MASK)) {
 			case IS_LONG:
 			case IS_RESOURCE:
 			case IS_BOOL:
@@ -125,12 +165,22 @@ proc_unicode:
 #endif
 
 			case IS_ARRAY:
+#ifdef IS_CONSTANT_ARRAY
 			case IS_CONSTANT_ARRAY:
+#endif
+				assert(SRC()->value.ht);
 				STRUCT_P(HashTable, value.ht, HashTable_zval_ptr)
 				break;
 
+#ifdef IS_CONSTANT_AST
+			case IS_CONSTANT_AST:
+				assert(SRC()->value.ast);
+				ZEND_AST_HELPER(`SRC()->value.ast', `STRUCT_P(zend_ast, value.ast)')
+				break;
+#endif
+
 			case IS_OBJECT:
-				IFNOTMEMCPY(`IFCOPY(`memcpy(dst, src, sizeof(src[0]));')')
+				IFNOTMEMCPY(`IFCOPY(`memcpy(DST(), SRC(), sizeof(SRC()[0]));')')
 				dnl STRUCT(value.obj)
 #ifndef ZEND_ENGINE_2
 				STRUCT_P(zend_class_entry, value.obj.ce)
@@ -164,40 +214,39 @@ dnl }}}
 DEF_STRUCT_P_FUNC(`zval_ptr', , `dnl {{{
 	IFDASM(`
 		pushdefFUNC_NAME(`zval')
-		FUNC_NAME (dasm, dst, src[0] TSRMLS_CC);
+		FUNC_NAME (dasm, DST(), SRC()[0] TSRMLS_CC);
 		popdef(`FUNC_NAME')
 	', `
 		do {
 			IFCALCCOPY(`
-				if (processor->reference) {
+				if (processor->handle_reference) {
 					zval_ptr *ppzv;
-					if (zend_hash_find(&processor->zvalptrs, (char *) &src[0], sizeof(src[0]), (void **) &ppzv) == SUCCESS) {
+					if (zend_hash_find(&processor->zvalptrs, (char *) &SRC()[0], sizeof(SRC()[0]), (void **) &ppzv) == SUCCESS) {
 						IFCOPY(`
-							dst[0] = *ppzv;
-							/* *dst is updated */
-							dnl fprintf(stderr, "*dst is set to %p, PROCESSOR_TYPE is_shm %d\n", dst[0], xc_is_shm(dst[0]));
+							DST()[0] = *ppzv;
+							/* *DST() is updated */
+							dnl fprintf(stderr, "*DST() is set to %p, PROCESSOR_TYPE is_shm %d\n", DST()[0], xc_is_shm(DST()[0]));
 						')
 						IFCALCSTORE(`processor->have_references = 1;')
-						IFSTORE(`assert(xc_is_shm(dst[0]));')
-						IFRESTORE(`assert(!xc_is_shm(dst[0]));')
+						IFSTORE(`assert(xc_is_shm(DST()[0]));')
+						IFRESTORE(`assert(!xc_is_shm(DST()[0]));')
 						break;
 					}
 				}
 			')
 			
-			ALLOC(dst[0], zval)
+			ALLOC(DST()[0], zval)
 			IFCALCCOPY(`
-				if (processor->reference) {
+				if (processor->handle_reference) {
 					IFCALC(`
 						/* make dummy */
 						zval_ptr pzv = (zval_ptr)-1;
 					', `
-						zval_ptr pzv = dst[0];
-						FIXPOINTER_EX(zval, pzv)
+						zval_ptr pzv = DST()[0];
+						RELOCATE_EX(zval, pzv)
 					')
-					if (zend_hash_add(&processor->zvalptrs, (char *) &src[0], sizeof(src[0]), (void *) &pzv, sizeof(pzv), NULL) == SUCCESS) {
-						/* first add, go on */
-						dnl fprintf(stderr, "mark[%p] = %p\n", src[0], pzv);
+					if (zend_hash_add(&processor->zvalptrs, (char *) &SRC()[0], sizeof(SRC()[0]), (void *) &pzv, sizeof(pzv), NULL) == SUCCESS) { /* first add, go on */
+						dnl fprintf(stderr, "mark[%p] = %p\n", SRC()[0], pzv);
 					}
 					else {
 						assert(0);
@@ -205,24 +254,24 @@ DEF_STRUCT_P_FUNC(`zval_ptr', , `dnl {{{
 				}
 			')
 			IFCOPY(`
-				dnl fprintf(stderr, "copy from %p to %p\n", src[0], dst[0]);
+				dnl fprintf(stderr, "copy from %p to %p\n", SRC()[0], DST()[0]);
 			')
-			IFDPRINT(`INDENT()`'fprintf(stderr, "[%p] ", (void *) src[0]);')
-			STRUCT_P_EX(zval, dst[0], src[0], `[0]', `', ` ')
-			FIXPOINTER_EX(zval, dst[0])
+			IFDPRINT(`INDENT()`'fprintf(stderr, "[%p] ", (void *) SRC()[0]);')
+			STRUCT_P_EX(zval, DST()[0], SRC()[0], `[0]', `', ` ')
+			RELOCATE_EX(zval, DST()[0])
 		} while (0);
 	')
 	DONE_SIZE(sizeof(zval_ptr))
 ')
 dnl }}}
 DEF_STRUCT_P_FUNC(`zval_ptr_nullable', , `dnl {{{
-	if (src[0]) {
+	if (SRC()[0]) {
 		pushdef(`DASM_STRUCT_DIRECT')
-		STRUCT_P_EX(zval_ptr, dst, src, `', `', ` ')
+		STRUCT_P_EX(zval_ptr, DST(), SRC(), `', `', ` ')
 		popdef(`DASM_STRUCT_DIRECT')
 	}
 	else {
-		IFCOPY(`COPYNULL_EX(src[0], src)')
+		IFCOPY(`COPYNULL_EX(DST()[0], SRC())')
 	}
 	DONE_SIZE(sizeof(zval_ptr_nullable))
 ')
@@ -238,8 +287,17 @@ DEF_STRUCT_P_FUNC(`zend_arg_info', , `dn
 #elif defined(ZEND_ENGINE_2_1)
 	PROCESS(zend_bool, array_type_hint)
 #endif
+#ifdef ZEND_ENGINE_2_6
+	PROCESS(zend_uchar, pass_by_reference)
+#endif
 	PROCESS(zend_bool, allow_null)
+
+#ifdef ZEND_ENGINE_2_6
+	PROCESS(zend_bool, is_variadic)
+#else
 	PROCESS(zend_bool, pass_by_reference)
+#endif
+
 #ifndef ZEND_ENGINE_2_4
 	PROCESS(zend_bool, return_reference)
 	PROCESS(int, required_num_args)
@@ -264,7 +322,7 @@ DEF_STRUCT_P_FUNC(`zend_function', , `dn
 	switch (SRC(`type')) {
 	case ZEND_INTERNAL_FUNCTION:
 	case ZEND_OVERLOADED_FUNCTION:
-		IFNOTMEMCPY(`IFCOPY(`memcpy(dst, src, sizeof(src[0]));')')
+		IFNOTMEMCPY(`IFCOPY(`memcpy(DST(), SRC(), sizeof(SRC()[0]));')')
 		break;
 
 	case ZEND_USER_FUNCTION:
@@ -277,7 +335,7 @@ DEF_STRUCT_P_FUNC(`zend_function', , `dn
 		assert(0);
 	}
 	')
-	DONE_SIZE(sizeof(src[0]))
+	DONE_SIZE(sizeof(SRC()[0]))
 ')
 dnl }}}
 #ifdef ZEND_ENGINE_2
@@ -330,12 +388,12 @@ dnl }}}
 DEF_STRUCT_P_FUNC(`zend_trait_alias_ptr', , `dnl {{{
 	IFDASM(`
 		pushdefFUNC_NAME(`zend_trait_alias')
-		FUNC_NAME (dasm, dst, src[0] TSRMLS_CC);
+		FUNC_NAME (dasm, DST(), SRC()[0] TSRMLS_CC);
 		popdef(`FUNC_NAME')
 	', `
-		ALLOC(dst[0], zend_trait_alias)
-		STRUCT_P_EX(zend_trait_alias, dst[0], src[0], `[0]', `', ` ')
-		FIXPOINTER_EX(zend_trait_alias, dst[0])
+		ALLOC(DST()[0], zend_trait_alias)
+		STRUCT_P_EX(zend_trait_alias, DST()[0], SRC()[0], `[0]', `', ` ')
+		RELOCATE_EX(zend_trait_alias, DST()[0])
 	')
 	DONE_SIZE(sizeof(zend_trait_alias))
 ')
@@ -343,12 +401,12 @@ dnl }}}
 DEF_STRUCT_P_FUNC(`zend_trait_precedence_ptr', , `dnl {{{
 	IFDASM(`
 		pushdefFUNC_NAME(`zend_trait_precedence')
-		FUNC_NAME (dasm, dst, src[0] TSRMLS_CC);
+		FUNC_NAME (dasm, DST(), SRC()[0] TSRMLS_CC);
 		popdef(`FUNC_NAME')
 	', `
-		ALLOC(dst[0], zend_trait_precedence)
-		STRUCT_P_EX(zend_trait_precedence, dst[0], src[0], `[0]', `', ` ')
-		FIXPOINTER_EX(zend_trait_precedence, dst[0])
+		ALLOC(DST()[0], zend_trait_precedence)
+		STRUCT_P_EX(zend_trait_precedence, DST()[0], SRC()[0], `[0]', `', ` ')
+		RELOCATE_EX(zend_trait_precedence, DST()[0])
 	')
 	DONE_SIZE(sizeof(zend_trait_precedence))
 ')
@@ -356,8 +414,8 @@ dnl }}}
 #endif
 DEF_STRUCT_P_FUNC(`zend_class_entry', , `dnl {{{
 	IFCALCCOPY(`
-		processor->active_class_entry_src = src;
-		IFCOPY(`processor->active_class_entry_dst = dst;')
+		processor->active_class_entry_src = SRC();
+		IFCOPY(`processor->active_class_entry_dst = DST();')
 	')
 	PROCESS(char, type)
 	PROCESS(zend_uint, name_length)
@@ -365,7 +423,7 @@ DEF_STRUCT_P_FUNC(`zend_class_entry', ,
 	IFRESTORE(`
 #ifndef ZEND_ENGINE_2
 		/* just copy parent and resolve on install_class */
-		COPY(parent)
+		COPYPOINTER(parent)
 #else
 		PROC_CLASS_ENTRY_P(parent)
 #endif
@@ -457,48 +515,51 @@ DEF_STRUCT_P_FUNC(`zend_class_entry', ,
 
 	/* # NOT DONE */
 #	ifdef ZEND_ENGINE_2_1
-	COPY(serialize_func)
-	COPY(unserialize_func)
+	PROCESS_CTEXTPOINTER(serialize_func)
+	PROCESS_CTEXTPOINTER(unserialize_func)
 #	endif
-	COPY(iterator_funcs)
-	COPY(create_object)
-	COPY(get_iterator)
-	COPY(interface_gets_implemented)
+	PROCESS_CTEXTPOINTER(iterator_funcs)
+	PROCESS_CTEXTPOINTER(create_object)
+	PROCESS_CTEXTPOINTER(get_iterator)
+	PROCESS_CTEXTPOINTER(interface_gets_implemented)
 #	ifdef ZEND_ENGINE_2_3
-	COPY(get_static_method)
+	PROCESS_CTEXTPOINTER(get_static_method)
 #	endif
 #	ifdef ZEND_ENGINE_2_1
-	COPY(serialize)
-	COPY(unserialize)
+	PROCESS_CTEXTPOINTER(serialize)
+	PROCESS_CTEXTPOINTER(unserialize)
 #	endif
 	/* deal with it inside xc_fix_method */
 	SETNULL(constructor)
-	COPY(destructor)
-	COPY(clone)
-	COPY(__get)
-	COPY(__set)
+	PROCESS_CTEXTPOINTER(destructor)
+	PROCESS_CTEXTPOINTER(clone)
+	PROCESS_CTEXTPOINTER(__get)
+	PROCESS_CTEXTPOINTER(__set)
 /* should be >5.1 */
 #	ifdef ZEND_ENGINE_2_1
-	COPY(__unset)
-	COPY(__isset)
-#	 if defined(ZEND_ENGINE_2_2) || PHP_MAJOR_VERSION >= 6
-	COPY(__tostring)
-#	 endif
+	PROCESS_CTEXTPOINTER(__unset)
+	PROCESS_CTEXTPOINTER(__isset)
 #	endif
-	COPY(__call)
+# if defined(ZEND_ENGINE_2_2) || PHP_MAJOR_VERSION >= 6
+	PROCESS_CTEXTPOINTER(__tostring)
+# endif
+# if defined(ZEND_ENGINE_2_6)
+	PROCESS_CTEXTPOINTER(__debugInfo)
+# endif
+	PROCESS_CTEXTPOINTER(__call)
 #	ifdef ZEND_CALLSTATIC_FUNC_NAME
-	COPY(__callstatic)
+	PROCESS_CTEXTPOINTER(__callstatic)
 #	endif
 #	ifndef ZEND_ENGINE_2_4
 	/* # NOT DONE */
-	COPY(module)
+	PROCESS_CTEXTPOINTER(module)
 #	endif
 #else /* ZEND_ENGINE_2 */
-	COPY(handle_function_call)
-	COPY(handle_property_get)
-	COPY(handle_property_set)
+	PROCESS_CTEXTPOINTER(handle_function_call)
+	PROCESS_CTEXTPOINTER(handle_property_get)
+	PROCESS_CTEXTPOINTER(handle_property_set)
 #endif
-	dnl must do after SETNULL(constructor) and dst->parent
+	dnl must do after SETNULL(constructor) and DST()->parent
 	STRUCT(HashTable, function_table, HashTable_zend_function)
 	IFRESTORE(`DST(`function_table.pDestructor') = ZEND_FUNCTION_DTOR;')
 	IFCALCCOPY(`
@@ -536,7 +597,7 @@ define(`UNION_znode_op', `dnl {{{
 					ALLOC_INIT_ZVAL(zv);
 					*zv = dasm->active_op_array_src->literals[SRC(`$1.constant')].constant;
 					zval_copy_ctor(zv);
-					add_assoc_zval_ex(dst, XCACHE_STRS("$1.constant"), zv);
+					add_assoc_zval_ex(DST(), XCACHE_STRS("$1.constant"), zv);
 				}
 				', `
 					IFCOPY(`
@@ -550,7 +611,7 @@ define(`UNION_znode_op', `dnl {{{
 		IFCOPY(`
 			IFNOTMEMCPY(`
 				default:
-					$1 = $2;
+					DST(`$1') = SRC(`$1');
 			')
 		', `
 		case IS_VAR:
@@ -592,7 +653,7 @@ DEF_STRUCT_P_FUNC(`znode', , `dnl {{{
 		IFCOPY(`
 			IFNOTMEMCPY(`
 				default:
-					memcpy(&DST(`u'), &SRC(`u'), sizeof(SRC(`u')));
+					DST(`u') = SRC(`u');
 			')
 		', `
 		case IS_VAR:
@@ -626,7 +687,7 @@ DEF_STRUCT_P_FUNC(`zend_op', , `dnl {{{
 	IFRESTORE(`', `
 	switch (SRC(`opcode')) {
 	case ZEND_BIND_TRAITS:
-		((zend_op *) src)->op2_type = IS_UNUSED;
+		((zend_op *) SRC())->op2_type = IS_UNUSED;
 		break;
 	}
 	')
@@ -673,7 +734,7 @@ DEF_STRUCT_P_FUNC(`zend_op', , `dnl {{{
 				Z_OP(DST(`op1')).jmp_addr = processor->active_op_array_dst->opcodes + (Z_OP(SRC(`op1')).jmp_addr - processor->active_op_array_src->opcodes);
 				assert(Z_OP(DST(`op1')).jmp_addr >= processor->active_op_array_dst->opcodes);
 				assert(Z_OP(DST(`op1')).jmp_addr - processor->active_op_array_dst->opcodes < processor->active_op_array_dst->last);
-				FIXPOINTER_EX(zend_op, `Z_OP(DST(`op1')).jmp_addr')
+				RELOCATE_EX(zend_op, `Z_OP(DST(`op1')).jmp_addr')
 				break;
 
 			case ZEND_JMPZ:
@@ -691,7 +752,7 @@ DEF_STRUCT_P_FUNC(`zend_op', , `dnl {{{
 				Z_OP(DST(`op2')).jmp_addr = processor->active_op_array_dst->opcodes + (Z_OP(SRC(`op2')).jmp_addr - processor->active_op_array_src->opcodes);
 				assert(Z_OP(DST(`op2')).jmp_addr >= processor->active_op_array_dst->opcodes);
 				assert(Z_OP(DST(`op2')).jmp_addr - processor->active_op_array_dst->opcodes < processor->active_op_array_dst->last);
-				FIXPOINTER_EX(zend_op, `Z_OP(DST(`op2')).jmp_addr')
+				RELOCATE_EX(zend_op, `Z_OP(DST(`op2')).jmp_addr')
 				break;
 
 			default:
@@ -714,11 +775,11 @@ dnl }}}
 #endif
 DEF_STRUCT_P_FUNC(`zend_op_array', , `dnl {{{
 	IFCOPY(`
-		processor->active_op_array_dst = dst;
-		processor->active_op_array_src = src;
+		processor->active_op_array_dst = DST();
+		processor->active_op_array_src = SRC();
 	')
 	IFDASM(`
-		dasm->active_op_array_src = src;
+		dasm->active_op_array_src = SRC();
 	')
 	{
 	IFRESTORE(`
@@ -731,7 +792,7 @@ DEF_STRUCT_P_FUNC(`zend_op_array', , `dn
 #else
 	zend_bool need_early_binding = processor->php_src->have_early_binding;
 #endif
-	zend_bool shallow_copy = !processor->readonly_protection && !(src == processor->php_src->op_array && need_early_binding);
+	zend_bool shallow_copy = !processor->readonly_protection && !(SRC() == processor->php_src->op_array && need_early_binding);
 	if (shallow_copy) {
 		zend_bool gc_arg_info = 0;
 		zend_bool gc_opcodes  = 0;
@@ -739,7 +800,7 @@ DEF_STRUCT_P_FUNC(`zend_op_array', , `dn
 		zend_bool gc_literals = 0;
 #endif
 		/* really fast shallow copy */
-		memcpy(dst, src, sizeof(src[0]));
+		memcpy(DST(), SRC(), sizeof(SRC()[0]));
 		DST(`refcount') = &XG(op_array_dummy_refcount_holder);
 		XG(op_array_dummy_refcount_holder) = ((zend_uint) -1) / 2;
 #ifdef ZEND_ACC_ALIAS
@@ -750,22 +811,24 @@ DEF_STRUCT_P_FUNC(`zend_op_array', , `dn
 		/* deep */
 		STRUCT_P(HashTable, static_variables, HashTable_zval_ptr)
 #ifdef ZEND_ENGINE_2
-		STRUCT_ARRAY(zend_uint, num_args, zend_arg_info, arg_info)
-		gc_arg_info = 1;
+		if (SRC(`arg_info')) {
+			gc_arg_info = 1;
+			STRUCT_ARRAY(zend_uint, num_args, zend_arg_info, arg_info)
+		}
 #endif
 		DST(`filename') = processor->entry_php_src->filepath;
+
 #ifdef ZEND_ENGINE_2_4
-		if (SRC(`literals')) {
+		if (SRC(`literals') && op_array_info->literalinfo_cnt) {
 			gc_opcodes = 1;
-			if (op_array_info->literalinfo_cnt) {
-				gc_literals = 1;
-			}
+			gc_literals = 1;
 		}
 #else
 		if (op_array_info->oplineinfo_cnt) {
 			gc_opcodes = 1;
 		}
 #endif
+
 #ifdef ZEND_ENGINE_2_4
 		if (gc_literals) {
 			dnl used when copying opcodes
@@ -867,7 +930,7 @@ DEF_STRUCT_P_FUNC(`zend_op_array', , `dn
 			for (i = 0; i < SRC(`arg_types[0]'); i ++) {
 				add_next_index_long(zv, SRC(`arg_types[i + 1]'));
 			}
-			add_assoc_zval_ex(dst, ZEND_STRS("arg_types"), zv);
+			add_assoc_zval_ex(DST(), ZEND_STRS("arg_types"), zv);
 		} while (0);')
 		DONE(arg_types)
 	}
@@ -883,11 +946,12 @@ DEF_STRUCT_P_FUNC(`zend_op_array', , `dn
 	dnl SETNULL(u_twin)
 #endif
 
+	IFSTORE(`pushdef(`RELOCATE_EX')')
 	STRUCT_P(zend_uint, refcount)
 	IFSTORE(`
-		UNFIXPOINTER(zend_uint, refcount)
+		popdef(`RELOCATE_EX')
 		DST(`refcount[0]') = 1;
-		FIXPOINTER(zend_uint, refcount)
+		RELOCATE(zend_uint, refcount)
 	')
 
 #ifdef ZEND_ENGINE_2_4
@@ -912,7 +976,7 @@ DEF_STRUCT_P_FUNC(`zend_op_array', , `dn
 #else
 	dnl zend_cv.m4 is illegal to be made public, don not ask me for it
 	IFDASM(`
-		sinclude(srcdir`/processor/zend_cv.m4')
+		sinclude(__dir__`/zend_cv.m4')
 		')
 #endif
 
@@ -943,7 +1007,7 @@ DEF_STRUCT_P_FUNC(`zend_op_array', , `dn
 	STRUCT_P(HashTable, static_variables, HashTable_zval_ptr)
 
 #ifndef ZEND_ENGINE_2_4
-	COPY(start_op)
+	COPYPOINTER(start_op)
 	PROCESS(int, backpatch_count)
 #endif
 #ifdef ZEND_ENGINE_2_3
@@ -961,7 +1025,7 @@ DEF_STRUCT_P_FUNC(`zend_op_array', , `dn
 	IFRESTORE(`DST(`filename') = processor->entry_php_src->filepath;DONE(filename)', `PROC_STRING(filename)')
 #ifdef IS_UNICODE
 	IFRESTORE(`
-		COPY(script_encoding)
+		COPYPOINTER(script_encoding)
 	', `
 		PROC_STRING(script_encoding)
 	')
@@ -986,7 +1050,7 @@ DEF_STRUCT_P_FUNC(`zend_op_array', , `dn
 	PROCESS(int, last_cache_slot)
 #endif
 	} while (0);
-	IFRESTORE(`xc_fix_op_array_info(processor->entry_php_src, processor->php_src, dst, shallow_copy, op_array_info TSRMLS_CC);')
+	IFRESTORE(`xc_fix_op_array_info(processor->entry_php_src, processor->php_src, DST(), shallow_copy, op_array_info TSRMLS_CC);')
 
 #ifdef ZEND_ENGINE_2
 	dnl mark it as -1 on store, and lookup parent on restore
@@ -1023,14 +1087,14 @@ DEF_STRUCT_P_FUNC(`zend_op_array', , `dn
 	PROC_CLASS_ENTRY_P(scope)
 	IFCOPY(`
 		if (SRC(`scope')) {
-			xc_fix_method(processor, dst TSRMLS_CC);
+			xc_fix_method(processor, DST() TSRMLS_CC);
 		}
 	')
 #endif
 
 	IFRESTORE(`
 		if (xc_have_op_array_ctor) {
-			zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) xc_zend_extension_op_array_ctor_handler, dst TSRMLS_CC);
+			zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) xc_zend_extension_op_array_ctor_handler, DST() TSRMLS_CC);
 		}
 	')
 	}
@@ -1050,7 +1114,7 @@ DEF_STRUCT_P_FUNC(`xc_constinfo_t', , `d
 #ifdef IS_UNICODE
 	PROCESS(zend_uchar, type)
 #endif
-	IFRESTORE(`COPY(key)', `
+	IFRESTORE(`COPYPOINTER(key)', `
 		PROC_ZSTRING_N(type, key, key_size)
 	')
 	PROCESS(ulong, h)
@@ -1080,11 +1144,11 @@ DEF_STRUCT_P_FUNC(`xc_funcinfo_t', , `dn
 #ifdef IS_UNICODE
 	PROCESS(zend_uchar, type)
 #endif
-	IFRESTORE(`COPY(key)', `
+	IFRESTORE(`COPYPOINTER(key)', `
 		PROC_ZSTRING_N(type, key, key_size)
 	')
 	PROCESS(ulong, h)
-	IFRESTORE(`COPY(op_array_info)', `
+	IFRESTORE(`COPYPOINTER(op_array_info)', `
 		STRUCT(xc_op_array_info_t, op_array_info)
 	')
 	IFRESTORE(`
@@ -1099,12 +1163,12 @@ DEF_STRUCT_P_FUNC(`xc_classinfo_t', , `d
 #ifdef IS_UNICODE
 	PROCESS(zend_uchar, type)
 #endif
-	IFRESTORE(`COPY(key)', `
+	IFRESTORE(`COPYPOINTER(key)', `
 		PROC_ZSTRING_N(type, key, key_size)
 	')
 	PROCESS(ulong, h)
 	PROCESS(zend_uint, methodinfo_cnt)
-	IFRESTORE(`COPY(methodinfos)', `
+	IFRESTORE(`COPYPOINTER(methodinfos)', `
 		STRUCT_ARRAY(zend_uint, methodinfo_cnt, xc_op_array_info_t, methodinfos)
 	')
 	IFRESTORE(`
@@ -1128,7 +1192,7 @@ DEF_STRUCT_P_FUNC(`xc_autoglobal_t', , `
 #ifdef IS_UNICODE
 	PROCESS(zend_uchar, type)
 #endif
-	IFRESTORE(`COPY(key)', `
+	IFRESTORE(`COPYPOINTER(key)', `
 		PROC_ZSTRING_L(type, key, key_len)
 	')
 	PROCESS(ulong, h)
@@ -1149,8 +1213,8 @@ dnl }}}
 ')
 DEF_STRUCT_P_FUNC(`xc_entry_data_php_t', , `dnl {{{
 	IFCOPY(`
-		processor->php_dst = dst;
-		processor->php_src = src;
+		processor->php_dst = DST();
+		processor->php_src = SRC();
 	')
 
 	/* skip */
@@ -1162,7 +1226,7 @@ DEF_STRUCT_P_FUNC(`xc_entry_data_php_t',
 	PROCESS(zend_ulong, hits)
 	PROCESS(size_t, size)
 
-	IFRESTORE(`COPY(op_array_info)', `
+	IFRESTORE(`COPYPOINTER(op_array_info)', `
 		STRUCT(xc_op_array_info_t, op_array_info)
 	')
 	IFRESTORE(`
@@ -1180,11 +1244,11 @@ DEF_STRUCT_P_FUNC(`xc_entry_data_php_t',
 	STRUCT_ARRAY(zend_uint, funcinfo_cnt, xc_funcinfo_t, funcinfos)
 
 	PROCESS(zend_uint, classinfo_cnt)
-	STRUCT_ARRAY(zend_uint, classinfo_cnt, xc_classinfo_t, classinfos, , IFRESTORE(`processor->active_class_index'))
+	STRUCT_ARRAY(zend_uint, classinfo_cnt, xc_classinfo_t, classinfos, , IFCOPY(`processor->active_class_index'))
 #ifdef ZEND_ENGINE_2_1
 	PROCESS(zend_uint, autoglobal_cnt)
 	IFRESTORE(`
-		COPY(autoglobals)
+		COPYPOINTER(autoglobals)
 	', `
 		STRUCT_ARRAY(zend_uint, autoglobal_cnt, xc_autoglobal_t, autoglobals)
 	')
@@ -1192,7 +1256,7 @@ DEF_STRUCT_P_FUNC(`xc_entry_data_php_t',
 #ifdef XCACHE_ERROR_CACHING
 	PROCESS(zend_uint, compilererror_cnt)
 	IFRESTORE(`
-		COPY(compilererrors)
+		COPYPOINTER(compilererrors)
 	', `
 		STRUCT_ARRAY(zend_uint, compilererror_cnt, xc_compilererror_t, compilererrors)
 	')
@@ -1220,12 +1284,12 @@ DEF_STRUCT_P_FUNC(`xc_entry_php_t', , `d
 	STRUCT(xc_entry_t, entry)
 	DISABLECHECK(`
 		PROCESS(int, entry.name.str.len)
-		IFRESTORE(`COPY(entry.name.str.val)', `
+		IFRESTORE(`COPYPOINTER(entry.name.str.val)', `
 			PROC_STRING_L(entry.name.str.val, entry.name.str.len)
 		')
 	')
 
-	IFCALCCOPY(`COPY(php)', `STRUCT_P(xc_entry_data_php_t, php)')
+	IFCALCCOPY(`COPYPOINTER(php)', `STRUCT_P(xc_entry_data_php_t, php)')
 
 	IFSTORE(`DST(`refcount') = 0; DONE(refcount)', `PROCESS(long, refcount)')
 	PROCESS(time_t, file_mtime)
@@ -1234,14 +1298,14 @@ DEF_STRUCT_P_FUNC(`xc_entry_php_t', , `d
 	PROCESS(size_t, file_inode)
 
 	PROCESS(size_t, filepath_len)
-	IFRESTORE(`COPY(filepath)', `PROC_STRING_L(filepath, filepath_len)')
+	IFRESTORE(`COPYPOINTER(filepath)', `PROC_STRING_L(filepath, filepath_len)')
 	PROCESS(size_t, dirpath_len)
-	IFRESTORE(`COPY(dirpath)', `PROC_STRING_L(dirpath, dirpath_len)')
+	IFRESTORE(`COPYPOINTER(dirpath)', `PROC_STRING_L(dirpath, dirpath_len)')
 #ifdef IS_UNICODE
 	PROCESS(int, ufilepath_len)
-	IFRESTORE(`COPY(ufilepath)', `PROC_USTRING_L(ufilepath, ufilepath_len)')
+	IFRESTORE(`COPYPOINTER(ufilepath)', `PROC_USTRING_L(ufilepath, ufilepath_len)')
 	PROCESS(int, udirpath_len)
-	IFRESTORE(`COPY(udirpath)', `PROC_USTRING_L(udirpath, udirpath_len)')
+	IFRESTORE(`COPYPOINTER(udirpath)', `PROC_USTRING_L(udirpath, udirpath_len)')
 #endif
 ')
 dnl }}}
@@ -1263,7 +1327,7 @@ DEF_STRUCT_P_FUNC(`xc_entry_var_t', , `d
 #else
 		PROCESS(int, entry.name.str.len)
 #endif
-		IFRESTORE(`COPY(entry.name.str.val)', `
+		IFRESTORE(`COPYPOINTER(entry.name.str.val)', `
 #ifdef IS_UNICODE
 			PROC_ZSTRING_L(name_type, entry.name.uni.val, entry.name.uni.len)
 #else
--- xcache.orig/processor/string.m4
+++ xcache/processor/string.m4
@@ -63,7 +63,7 @@ define(`PROC_STRING_N_EX', `
 		IFRESTORE(`
 			DSTPTR = ifdef(`REALPTRTYPE', `(REALPTRTYPE() *)') STRDUP() (SRCPTR, ($3) - 1);
 		')
-		FIXPOINTER_EX(ifdef(`REALPTRTYPE', `REALPTRTYPE()', `PTRTYPE'), DSTPTR)
+		RELOCATE_EX(ifdef(`REALPTRTYPE', `REALPTRTYPE()', `PTRTYPE'), DSTPTR)
 		IFDASM(`
 			ifelse(STRTYPE,zstr_uchar, `
 				add_assoc_unicodel_ex(dst, XCACHE_STRS("$4"), ZSTR_U($2), $3-1, 1);
--- xcache.orig/processor/struct.m4
+++ xcache/processor/struct.m4
@@ -4,14 +4,18 @@ define(`pushdefFUNC_NAME', `
 dnl {{{ DECL_STRUCT_P_FUNC(1:type, 2:name, 3:comma=;)
 define(`DECL_STRUCT_P_FUNC', `translit(
 	pushdefFUNC_NAME(`$1', `$2')
-	define(`DEFINED_'ifelse(`$2', `', `$1', `$2'), `')
-	ifdef(`EXPORT_'ifelse(`$2', `', `$1', `$2'), `void', `static void inline')
+	pushdef(`type', `ifelse(`$2', `', `$1', `$2')')
+	define(`DEFINED_'type, `')
+	ifelse(ifdef(`EXPORT_'PROCESSOR_TYPE`_'type,1)ifdef(`EXPORT_'PROCESSOR_TYPE`_',1)ifdef(`EXPORT__'type,1), `', `static void inline',
+		`', `', `void')
+	popdef(`type')
 	FUNC_NAME`'(
 		IFDPRINT( `const $1 * const src, int indent')
 		IFCALC(   `xc_processor_t *processor, const $1 * const src')
 		IFSTORE(  `xc_processor_t *processor, $1 *dst, const $1 * const src')
 		IFRESTORE(`xc_processor_t *processor, $1 *dst, const $1 * const src')
-		IFDASM(   `xc_dasm_t *dasm, zval *dst, const $1 * const src')
+		PROCRELOCATE(`$1 *const dst, ptrdiff_t ptrdiff, ptrdiff_t relocatediff')
+		IFDASM(`xc_dasm_t *dasm, zval *dst, const $1 * const src')
 		TSRMLS_DC
 	)ifelse(`$3', `', `;')
 	popdef(`FUNC_NAME')dnl
@@ -22,10 +26,12 @@ dnl {{{ DEF_STRUCT_P_FUNC(1:type, 2:name
 define(`DEF_STRUCT_P_FUNC', `
 	pushdefFUNC_NAME(`$1', `$2')
 /* {`{'{ FUNC_NAME */
-	ifdef(`EXPORT_'ifelse(`$2', `', `$1', `$2'), `
-		/* export: DECL_STRUCT_P_FUNC(`$1', `$2') :export */
-	')
-DECL_STRUCT_P_FUNC(`$1', `$2', 1)
+	pushdef(`type', `ifelse(`$2', `', `$1', `$2')')
+	define(`DEFINED_'type, `')
+	ifelse(ifdef(`EXPORT_'PROCESSOR_TYPE`_'type,1)ifdef(`EXPORT_'PROCESSOR_TYPE`_',1)ifdef(`EXPORT__'type,1), `', `',
+		`', `', `EXPORT(`DECL_STRUCT_P_FUNC(`$1', `$2')')')
+	popdef(`type')
+DECL_STRUCT_P_FUNC(`$1', `$2', ` ')
 	{
 		pushdef(`ELEMENTS_DONE')
 		IFAUTOCHECK(`
@@ -56,28 +62,27 @@ DECL_STRUCT_P_FUNC(`$1', `$2', 1)
 			HashTable xc_autocheck_done_names;
 			zend_hash_init(&xc_autocheck_done_names, 0, NULL, NULL, 0);
 			/* }}} */
-			IFRESTORE(`assert(xc_is_shm(src));')
-			IFCALCSTORE(`assert(!xc_is_shm(src));')
-			do {
+			IFRESTORE(`assert(xc_is_shm(SRC()));')
+			IFCALCSTORE(`assert(!xc_is_shm(SRC()));')
 		')
 		ifdef(`SIZEOF_$1', , `m4_errprint(`AUTOCHECK WARN: $1: missing structinfo, dont panic')')
 
 		ifdef(`USEMEMCPY', `IFCOPY(`
-			memcpy(dst, src, sizeof($1));
-			do {
+			memcpy(DST(), SRC(), sizeof($1));
 		')')
 
 		IFDPRINT(`
 			fprintf(stderr, "%s", "{\n");
 			indent ++;
-			{
 		')
-		$3`'
+		{
+			$3`'
+		}
 		IFDPRINT(`
-			}
 			indent --;
 			INDENT()fprintf(stderr, "}\n");
 		')
+
 		IFAUTOCHECK(`
 		/* {{{ autocheck */
 		if (!xc_autocheck_skip) {
@@ -104,22 +109,19 @@ DECL_STRUCT_P_FUNC(`$1', `$2', 1)
 		zend_hash_destroy(&xc_autocheck_done_names);
 		/* }}} */
 		')
-		ifdef(`ELEMENTSOF_$1', `
-			pushdef(`ELEMENTS_UNDONE', LIST_DIFF(defn(`ELEMENTSOF_$1'), defn(`ELEMENTS_DONE')))
-			ifelse(defn(`ELEMENTS_UNDONE'), , `m4_errprint(`AUTOCHECK INFO: $1: processor looks good')', `
-				m4_errprint(`AUTOCHECK ERROR: ====' PROCESSOR_TYPE `$1 =================')
-				m4_errprint(`AUTOCHECK expected:' defn(`ELEMENTSOF_$1'))
-				m4_errprint(`AUTOCHECK missing :' defn(`ELEMENTS_UNDONE'))
-				define(`EXIT_PENDING', 1)
+		ifdef(`AUTOCHECK_SKIP', `undefine(`AUTOCHECK_SKIP')', `
+			ifdef(`ELEMENTSOF_$1', `
+				pushdef(`ELEMENTS_UNDONE', LIST_DIFF(defn(`ELEMENTSOF_$1'), defn(`ELEMENTS_DONE')))
+				ifelse(defn(`ELEMENTS_UNDONE'), , `m4_errprint(`AUTOCHECK INFO: $1: processor looks good')', `
+					m4_errprint(`AUTOCHECK ERROR: ====' PROCESSOR_TYPE `$1 =================')
+					m4_errprint(`AUTOCHECK expected:' defn(`ELEMENTSOF_$1'))
+					m4_errprint(`AUTOCHECK missing :' defn(`ELEMENTS_UNDONE'))
+					define(`EXIT_PENDING', 1)
+				')
+				popdef(`ELEMENTS_UNDONE')
 			')
-			popdef(`ELEMENTS_UNDONE')
-		')
-		ifdef(`USEMEMCPY', `IFCOPY(`
-			} while (0);
-		')')
-		IFAUTOCHECK(`
-			} while (0);
 		')
+
 		popdef(`ELEMENTS_DONE')
 	}
 /* }`}'} */
@@ -145,17 +147,22 @@ ifdef(`DASM_STRUCT_DIRECT', `', `
 		IFCALC(   `processor, $6 $3')
 		IFSTORE(  `processor, $6 $2, $6 $3')
 		IFRESTORE(`processor, $6 $2, $6 $3')
-		IFDASM(   `dasm, ifdef(`DASM_STRUCT_DIRECT', `dst', `zv'), $6 $3')
+		PROCRELOCATE(`
+			ifelse(`$6', `', `PTR_FROM_VIRTUAL_EX(`$1', `$3')', `$6 $3')
+			, ptrdiff
+			, relocatediff
+		')
+		IFDASM(`dasm, ifdef(`DASM_STRUCT_DIRECT', `DST()', `zv'), $6 $3')
 		TSRMLS_CC
 	);
 ifdef(`DASM_STRUCT_DIRECT', `', `
 	IFDASM(`
-		add_assoc_zval_ex(dst, XCACHE_STRS("$4"), zv);
+		add_assoc_zval_ex(DST(), XCACHE_STRS("$4"), zv);
 	} while (0);
 	')
 ')
 	popdef(`FUNC_NAME')
-	ifelse(`$6', , `FIXPOINTER_EX(`$1', `$2')')
+	ifelse(`$6', , `RELOCATE_EX(`$1', `$2')')
 ')
 dnl }}}
 dnl {{{ STRUCT_P(1:type, 2:elm, 3:name=type)
@@ -204,7 +211,7 @@ define(`STRUCT_ARRAY', `
 				FUNC_NAME (dasm, zv, &(SRC(`$4[LOOPCOUNTER]')) TSRMLS_CC);
 				add_next_index_zval(arr, zv);
 			}
-			add_assoc_zval_ex(dst, XCACHE_STRS("$4"), arr);
+			add_assoc_zval_ex(DST(), XCACHE_STRS("$4"), arr);
 		', `
 			dnl find count with NULL
 			ifelse(`$2', `', `
@@ -224,13 +231,17 @@ define(`STRUCT_ARRAY', `
 					`', `', `LOOPCOUNTER < SRC(`$2')');
 					++LOOPCOUNTER) {
 				DISABLECHECK(`
-					STRUCT(`$3', `$4[LOOPCOUNTER]', `$5')
+					pushdef(`ALLOC')
+					pushdef(`RELOCATE_EX')
+					STRUCT_P_EX(`$3', (DST(`$4') + LOOPCOUNTER), (SRC(`$4') + LOOPCOUNTER), `', `$5')
+					popdef(`RELOCATE_EX')
+					popdef(`ALLOC')
 				')
 			}
 			dnl the end marker
 			ifelse(`$2', `', `IFCOPY(`DST(`$4[LOOPCOUNTER]') = NULL;')')
 		')dnl IFDASM
-		FIXPOINTER(`$3', `$4')
+		RELOCATE(`$3', `$4')
 		DONE(`$4')
 		popdef(`FUNC_NAME')
 		popdef(`LOOPCOUNTER')
--- xcache.orig/mod_disassembler/sample.cpp.php
+++ /dev/null
@@ -1,611 +0,0 @@
-<?php
-#if PHP_VERSION >= 500
-#	define PublicMethod public
-#else
-#	define ClassName classname
-#	define PublicMethod
-#	define abstract
-#	define innerIf_ innerif_
-#	define emptySwitch emptyswitch
-#	define defaultSwitch defaultswitch
-#endif
-#if PHP_VERSION >= 520
-#else
-#	define __callStatic __callstatic
-#	define __toString __tostring
-#endif
-#if PHP_VERSION >= 530
-
-namespace ns;
-#endif
-
-abstract class ClassName
-{
-#if PHP_VERSION >= 500
-	const CONST_VALUE = 'A constant value';
-
-	/** doc */
-	static public $static = array(
-		0           => array('array'),
-		1           => 'str',
-		CONST_VALUE => CONST_VALUE
-		);
-	static public $static_const1 = CONST_VALUE;
-	static public $static_const2 = self::CONST_VALUE;
-	static public $static_const3 = ClassName::CONST_VALUE;
-	static public $static_const4 = array(CONST_VALUE => 'test');
-	static public $static_const5 = array(self::CONST_VALUE => 'test');
-	static public $static_const6 = array(ClassName::CONST_VALUE => 'test');
-	static public $static_const7 = array('test' => CONST_VALUE);
-	static public $static_const8 = array('test' => self::CONST_VALUE);
-	static public $static_const9 = array('test' => ClassName::CONST_VALUE);
-	static public $static_const10 = array(CONST_VALUE => CONST_VALUE);
-	static public $static_const11 = array(self::CONST_VALUE => self::CONST_VALUE);
-	static public $static_const12 = array(ClassName::CONST_VALUE => ClassName::CONST_VALUE);
-	/** doc */
-	static public $public_static = array(2, 'str');
-	/** doc */
-	static private $private_static = array(2, 'str');
-	static private $private_static2 = array(self::CONST_VALUE => self::CONST_VALUE);
-	/** doc */
-	static protected $protected_static = array(2, 'str');
-	static protected $protected_static2 = array(self::CONST_VALUE => self::CONST_VALUE);
-	/** doc */
-	public $property = array(
-		array('array'),
-		'str'
-		);
-	/** doc */
-	public $public_property = array(2, 'str');
-	/** doc */
-	private $private_property = array(2, 'str');
-	/** doc */
-	protected $protected_property = array(2, 'str');
-#else
-	var $property = array(
-		array('array'),
-		'str'
-		);
-#endif
-
-#if PHP_VERSION >= 500
-	/** doc */
-#endif
-	PublicMethod function __construct($a, $b)
-	{
-		static $array = array(
-			0           => array('array'),
-			1           => 'str',
-			CONST_VALUE => CONST_VALUE
-			);
-		static $a = 1;
-		static $str = 'string';
-		echo CONST_VALUE;
-#if PHP_VERSION >= 500
-		echo ClassName::CONST_VALUE;
-		empty(ClassName::$classProp);
-		isset(ClassName::$classProp);
-		unset(ClassName::$classProp);
-		ClassName::$classProp = 1;
-		echo ClassName::$classProp;
-#endif
-		empty($obj->objProp);
-		isset($obj->objProp);
-#if PHP_VERSION >= 500
-		unset($obj->objProp);
-#endif
-		$obj->objProp = 1;
-		echo $obj->objProp;
-		empty($this->thisProp);
-		isset($this->thisProp);
-#if PHP_VERSION >= 500
-		unset($this->thisProp);
-#endif
-		$this->thisProp = 1;
-		echo $this->thisProp;
-#if PHP_VERSION >= 500
-		unset($array['index']->valueProp);
-#endif
-		unset($obj->array['index']);
-		unset($this->array['index']);
-		empty($_GET['get']);
-		isset($_GET['get']);
-		unset($_GET['get']);
-		$_GET['get'] = 1;
-		echo $_GET['get'];
-		isset($GLOBALS['global']);
-		empty($GLOBALS['global']);
-		unset($GLOBALS['global']);
-		$GLOBALS['global'] = 1;
-		echo $GLOBALS['global'];
-		empty($array['index']);
-		isset($array['index']);
-		unset($array['index']);
-		$array['index'] = 1;
-		echo $array['index'];
-		empty($array['index']->indexProp);
-		isset($array['index']->indexProp);
-#if PHP_VERSION >= 500
-		unset($array['index']->indexProp);
-#endif
-		$array['index']->indexProp = 1;
-		echo $array['index']->indexProp;
-		empty($GLOBALS['var']->indexProp);
-		isset($GLOBALS['var']->indexProp);
-#if PHP_VERSION >= 500
-		unset($GLOBALS['var']->indexProp);
-#endif
-		$GLOBALS['var']->indexProp = 1;
-		echo $GLOBALS['var']->indexProp;
-		ClassName::__construct();
-		ClassName::$func();
-		echo __CLASS__;
-		echo __METHOD__;
-		echo __FUNCTION__;
-		$this->methodCall();
-#if PHP_VERSION >= 500
-		throw new Exception();
-		new Exception();
-#endif
-	}
-#if PHP_VERSION >= 500
-
-	/** doc */
-	abstract public function abastractMethod();
-#endif
-
-#if PHP_VERSION >= 500
-	/** doc */
-#endif
-	PublicMethod function method($a = NULL, $b = NULL)
-	{
-	}
-#if PHP_VERSION >= 500
-
-	/** doc */
-	protected function protectedMethod(ClassName $a, $b = array(
-			array('array')
-			))
-	{
-		$runtimeArray = array('1');
-		$runtimeArray2 = array(
-			'1',
-			array()
-			);
-		$runtimeArray3 = array(
-			'a' => '1',
-			2   => array()
-			);
-		return 'protected';
-	}
-
-	/** doc */
-	private function privateMethod(ClassName $a, $b = NULL)
-	{
-		return 'private';
-	}
-#endif
-}
-#if PHP_VERSION >= 500
-
-interface IInterface
-{
-	public function nothing();
-}
-#endif
-
-function f1($f)
-{
-	echo __FUNCTION__;
-	echo $f;
-#if PHP_VERSION >= 550
-
-	foreach ($a as $b) {
-		yield $b;
-	}
-
-	yield f1($b);
-#endif
-}
-#if PHP_VERSION >= 500
-
-final class Child extends ClassName implements IInterface
-{
-	public function __construct()
-	{
-		parent::__construct();
-	}
-
-	public function __destruct()
-	{
-		parent::__destruct();
-		functionCall();
-	}
-
-	static public function __callStatic($name, $args)
-	{
-		parent::__callStatic($name, $args);
-	}
-
-	public function __toString()
-	{
-		parent::__toString();
-	}
-
-	public function __set($name, $value)
-	{
-	}
-
-	public function __get($name)
-	{
-	}
-
-	public function __isset($name)
-	{
-	}
-
-	public function __unset($name)
-	{
-	}
-
-	public function __sleep()
-	{
-	}
-
-	public function __wakeup()
-	{
-	}
-
-	public function __clone()
-	{
-		return array();
-	}
-}
-#endif
-
-if ($late) {
-	class LateBindingClass
-	{
-		PublicMethod function __construct()
-		{
-		}
-	}
-
-	function lateBindingFunction($arg)
-	{
-		echo 'lateFunction';
-		return new lateBindingFunction();
-	}
-}
-
-echo "\r\n";
-echo "\r";
-echo "\n";
-echo str_replace(array('a' => 'a', 'b' => 'c'), 'b');
-$object = new ClassName();
-$object = new $className();
-#if PHP_VERSION >= 500
-$result = $object instanceof ClassName;
-$cloned = clone $object;
-#endif
-$a = 1;
-$a = $b + $c;
-$a = $b + 1;
-$a = 1 + $b;
-$a = $b - $c;
-$a = $b * $c;
-$a = $b / $c;
-$a = $b % $c;
-$a = $b . $c;
-$a = $b = $c;
-$a = $b & $c;
-$a = $b | $c;
-$a = $b ^ $c;
-$a = ~$b;
-$a = -$b;
-$a = +$b;
-$a = $b >> $c;
-$a = $b >> $c;
-$a = $b == $c;
-$a = $b === $c;
-$a = $b != $c;
-$a = $b < $c;
-$a = $b <= $c;
-$a = $b <= $c;
-$a = $b++;
-$a = ++$b;
-$a = $obj->b++;
-$a = ++$obj->b;
-$a = $b--;
-$a = --$b;
-$a = $obj->b--;
-$a = --$obj->b;
-$a = !$b;
-$a = $b === $c;
-$a = $b !== $c;
-$a = $b << 2;
-$a = $b >> 3;
-$a += $b;
-$a -= $b;
-$a *= $b;
-$a /= $b;
-$a <<= $b;
-$a >>= $b;
-$a &= $b;
-$a |= $b;
-$a .= $b;
-$a %= $b;
-$a ^= $b;
-$a = 'a' . 'b';
-$a = 'a' . 'abc';
-@f1();
-print('1');
-$a = $array['index'];
-$a = $object->prop;
-$a = $this->prop;
-$array['index'] = 1;
-$object->prop = 1;
-$this->prop = 1;
-$a = isset($b);
-$a = empty($b);
-unset($b);
-$a = isset($array['index']);
-$a = empty($array['index']);
-unset($array['index']);
-$a = isset($object->prop);
-$a = empty($object->prop);
-#if PHP_VERSION >= 500
-unset($object->prop);
-#endif
-$a = isset($this->prop);
-$a = empty($this->prop);
-#if PHP_VERSION >= 500
-unset($this->prop);
-$a = isset(ClassName::$prop);
-$a = empty(ClassName::$prop);
-unset(ClassName::$prop);
-#endif
-$a = (int) $b;
-$a = (double) $b;
-$a = (string) $b;
-$a = (array) $b;
-$a = (object) $b;
-$a = (bool) $b;
-$a = (unset) $b;
-$a = (array) $b;
-$a = (object) $b;
-$a = ($b ? $c : $d);
-$a = (f1() ? f2() : f3());
-($a = $b) xor $c;
-($a = $b) and $c;
-($a = $b) or $c;
-$a = $b && $c;
-$a = $b || $c;
-#if PHP_VERSION >= 500
-
-do {
-	try {
-		echo 'outer try 1';
-
-		try {
-			echo 'inner try';
-		}
-		catch (InnerException $e) {
-			echo $e;
-		}
-		catch (InnerException2 $e2) {
-			echo $e2;
-		}
-#if PHP_VERSION >= 550
-		finally {
-			echo 'inner finally';
-		}
-#endif
-
-		echo 'outer try 2';
-	}
-	catch (OuterException $e) {
-		echo $e;
-	}
-	catch (OuterException2 $e2) {
-		echo $e2;
-	}
-#if PHP_VERSION >= 550
-	finally {
-		echo 'outer finally';
-	}
-#endif
-} while (0);
-#endif
-
-if (if_()) {
-	echo 'if';
-
-	if (innerIf_()) {
-		echo 'if innerIf';
-	}
-}
-else if (elseif_()) {
-	echo 'else if';
-
-	if (innerIf_()) {
-		echo 'if innerIf';
-	}
-}
-else {
-	if (innerIf_()) {
-		echo 'if innerIf';
-	}
-
-	echo 'else';
-}
-
-while (false) {
-	echo 'while';
-}
-
-do {
-	echo 'do/while';
-} while (false);
-
-$i = 1;
-
-for (; $i < 10; ++$i) {
-	echo $i;
-	break;
-}
-
-foreach ($array as $value) {
-	foreach ($value as $key => $value) {
-		echo $key . ' = ' . $value . "\n";
-		break 2;
-		continue;
-	}
-}
-
-switch ($normalSwitch) {
-case 'case1':
-	echo 'case1';
-
-	switch ($nestedSwitch) {
-	case 1:
-	}
-
-	break;
-
-case 'case2':
-	echo 'case2';
-	break;
-
-default:
-	switch ($nestedSwitch) {
-	case 1:
-	}
-
-	echo 'default';
-	break;
-}
-
-switch ($switchWithoutDefault) {
-case 'case1':
-	echo 'case1';
-	break;
-
-case 'case2':
-	echo 'case2';
-	break;
-}
-
-switch ($switchWithMiddleDefault) {
-case 'case1':
-	echo 'case1';
-	break;
-
-default:
-	echo 'default';
-	break;
-
-case 'case2':
-	echo 'case2';
-	break;
-}
-
-switch ($switchWithInitialDefault) {
-default:
-	echo 'default';
-	break;
-
-case 'case1':
-	echo 'case1';
-	break;
-
-case 'case2':
-	echo 'case2';
-	break;
-}
-
-switch (emptySwitch()) {
-}
-
-switch (defaultSwitch()) {
-default:
-}
-
-declare (ticks=1) {
-	echo 1;
-}
-
-while (1) {
-	declare (ticks=1) {
-		echo 2;
-	}
-}
-
-require 'require.php';
-require_once 'require_once.php';
-include 'include.php';
-include_once 'include_once.php';
-echo __FILE__;
-echo __LINE__;
-#if PHP_VERSION >= 530
-echo 'PHP 5.3+ code testing';
-const CONST_VALUE = 1;
-echo $this::CONST_VALUE;
-echo $a::CONST_VALUE;
-echo CONST_VALUE;
-$this::__construct();
-$obj::__construct();
-$a = $b ?: $d;
-$a = ($b ?: $d) + $c;
-$a = f1() ?: f2();
-$a = C::f1() ?: C::f2();
-$a = ($b ? $c : $d);
-$a = ($b ? $c : $d) + $c;
-$a = (f1() ? f3() : f2());
-
-if ($b ?: $d) {
-	echo 'if ($b ?: $d)';
-}
-
-if (($b ?: $d) + $c) {
-	echo 'if (($b ?: $d) + $c)';
-}
-
-if (f1() ?: f2()) {
-	echo 'if (f1() ?: f2())';
-}
-
-echo 'goto a';
-goto a;
-
-$i = 1;
-
-for (; $i <= 2; ++$i) {
-	goto a;
-}
-
-a:
-echo 'label a';
-echo preg_replace_callback('~-([a-z])~', function($match) {
-	return strtoupper($match[1]);
-}, 'hello-world');
-$greet = function($name) {
-	printf('Hello %s' . "\r\n" . '', $name);
-};
-$greet('World');
-$greet('PHP');
-$total = 0;
-$tax = 1;
-$callback = function($quantity, $product) use($tax, &$total) {
-	$tax = 'tax';
-	static $static1 = array(1);
-	static $static2;
-	$tax = 'tax';
-	$tax = --$tax;
-	$pricePerItem = constant('PRICE_' . strtoupper($product));
-	$total += $pricePerItem * $quantity * ($tax + 1);
-};
-#endif
-exit();
-
-?>
--- xcache.orig/mod_disassembler/xc_disassembler.c
+++ xcache/mod_disassembler/xc_disassembler.c
@@ -194,6 +194,14 @@ void xc_dasm_file(zval *output, const ch
 
 /* {{{ proto array xcache_dasm_file(string filename)
    Disassemble file into opcode array by filename */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_dasm_file, 0, 0, 1)
+	ZEND_ARG_INFO(0, filename)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_dasm_file[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_dasm_file)
 {
 	char *filename;
@@ -209,6 +217,14 @@ PHP_FUNCTION(xcache_dasm_file)
 /* }}} */
 /* {{{ proto array xcache_dasm_string(string code)
    Disassemble php code into opcode array */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_dasm_string, 0, 0, 1)
+	ZEND_ARG_INFO(0, code)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_dasm_string[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_dasm_string)
 {
 	zval *code;
@@ -232,8 +248,8 @@ static PHP_MINFO_FUNCTION(xcache_disasse
 /* }}} */
 static zend_function_entry xcache_disassembler_functions[] = /* {{{ */
 {
-	PHP_FE(xcache_dasm_file,         NULL)
-	PHP_FE(xcache_dasm_string,       NULL)
+	PHP_FE(xcache_dasm_file,         arginfo_xcache_dasm_file)
+	PHP_FE(xcache_dasm_string,       arginfo_xcache_dasm_string)
 	PHP_FE_END
 };
 /* }}} */
--- /dev/null
+++ xcache/devel/exportfunctions.php
@@ -0,0 +1,8 @@
+<?php
+
+$all_functions = get_defined_functions();
+$xcache_functions = preg_grep("/^xcache_/", $all_functions['internal']);
+foreach ($xcache_functions as $function) {
+	ReflectionFunction::export($function);
+}
+
--- xcache.orig/devel/prepare.cfg.example
+++ xcache/devel/prepare.cfg.example
@@ -5,9 +5,10 @@ PHP5_1_DIR=
 PHP5_3_DIR=
 PHP5_4_DIR=
 PHP5_5_DIR=
+PHP5_6_DIR=
 PHP6_x_DIR=
 
-PHP_DEVEL_DIR=
+PHP_DEVEL_DIR=$(PHP5_6_DIR)
 
 # path to eaccelerator source dir
 EA_DIR=
--- xcache.orig/devel/prepare.mak
+++ xcache/devel/prepare.mak
@@ -24,6 +24,7 @@ xc_const_string: \
 	xcache/xc_const_string_opcodes_php5.3.h \
 	xcache/xc_const_string_opcodes_php5.4.h \
 	xcache/xc_const_string_opcodes_php5.5.h \
+	xcache/xc_const_string_opcodes_php5.6.h \
 	xcache/xc_const_string_opcodes_php6.x.h
 
 ifeq (${EA_DIR},)
@@ -97,6 +98,15 @@ xcache/xc_const_string_opcodes_php5.5.h:
 	$(AWK) -f ./devel/gen_const_string_opcodes.awk < "$<" > "$@.tmp"
 	mv "$@.tmp" "$@"
 endif
+
+ifeq (${PHP5_6_DIR},)
+xcache/xc_const_string_opcodes_php5.6.h: dummy
+	@echo "Skipped $@: PHP_5_6_DIR not set"
+else
+xcache/xc_const_string_opcodes_php5.6.h: ${PHP5_6_DIR}/Zend/zend_vm_def.h
+	$(AWK) -f ./devel/gen_const_string_opcodes.awk < "$<" > "$@.tmp"
+	mv "$@.tmp" "$@"
+endif
 
 ifeq (${PHP6_x_DIR},)
 xcache/xc_const_string_opcodes_php6.x.h: dummy
--- xcache.orig/devel/run
+++ xcache/devel/run
@@ -129,7 +129,7 @@ hiecho "Loading config devel/run.cfg"
 PHPSDIR=${PHPSDIR:-$HOME/test}
 
 if [[ $# -eq 0 ]]; then
-	set -- $action "${args[@]}"
+	set -- "${args[@]}"
 fi
 
 basename=$(basename $(pwd))
@@ -233,31 +233,15 @@ run() {
 	# }}}1
 
 	if [[ -z $1 ]]; then
-		set -- devel.php
+		set -- devel/sample.cpp.php
 	fi
 
 	cmd=()
+	phpApp=()
 	tracer=()
 
 	# run utils {{{1
 	case "$1" in
-	dc)
-		shift
-		case "$1" in
-		*.cpp.php)
-			< "$1" \
-			sed -r -e 's#__#____#g' \
-			| cpp -C -P -traditional-cpp -DPHP_VERSION=$phpVersion \
-			| sed -r -e 's#^ +##g' -e 's#\t +#\t#g' -e 's#____#__#g' > sample.php || exit $?
-			shift
-			./php-cli -c devel.ini ./bin/phpdc.phpr sample.php "$@" | tee decompiled.php
-			;;
-		*)
-			./php-cli -c devel.ini ./bin/phpdc.phpr "$@" | tee decompiled.php
-			;;
-		esac
-		return
-		;;
 	retest)
 		shift
 		lastResult=$(ls php_test_results_*.txt | LANG=C sort | tail -n1)
@@ -318,10 +302,15 @@ run() {
 		;;
 	*)
 		case "$1" in
+		dc)
+			shift
+			cmd=(./php-cli -c devel.ini)
+			phpApp=(./bin/phpdc.phpr)
+			;;
 		dop)
 			shift
 			cmd=(./php-cli -c devel.ini)
-			set -- ./bin/phpdop.phpr "$@"
+			phpApp=(./bin/phpdop.phpr)
 			;;
 		fcgi)
 			shift
@@ -341,22 +330,42 @@ run() {
 		"${cmd[@]}" -v || true
 	esac
 
+	# hack sample.cpp.php {{{1
+	case "$1" in
+	*.cpp.php)
+		< "$1" \
+		sed -r -e 's#__#____#g' \
+		| cpp -C -P -traditional-cpp -DPHP_VERSION=$phpVersion \
+		| sed -r -e 's#^ +##g' -e 's#\t +#\t#g' -e 's#____#__#g' > devel.php || exit $?
+		shift
+		set -- devel.php "$@"
+		;;
+	esac
+
 	# run {{{1
-	commandLine=("${tracer[@]}" "${cmd[@]}" "$@")
+	set -- "${tracer[@]}" "${cmd[@]}" "${phpApp[@]}" "$@"
 
 	case "${cmd[0]}" in
 	*php-fpm*)
 		stopfpm
-		hiecho Starting fpm "${commandLine[@]}" ...
-		"${commandLine[@]}"
+		hiecho Starting fpm "$@" ...
+		"$@" | tee output.php
 		echo -n "Ctrl-C to stop"
 		trap cleanfpm SIGINT SIGTERM exit
 		cat > /dev/null || true
 		stopfpm
+		return
 		;;
 	*)
-		hiecho "${commandLine[@]}"
-		"${commandLine[@]}"
+		hiecho "$@"
+		case "${tracer[@]}" in
+		gdb*|val*)
+			"$@"
+			;;
+		*)
+			"$@" | tee output.php
+			;;
+		esac
 		;;
 	esac
 	# }}}
--- /dev/null
+++ xcache/devel/sample.cpp.php
@@ -0,0 +1,674 @@
+<?php
+#if PHP_VERSION >= 500
+#	define PublicMethod public
+#else
+#	define ClassName classname
+#	define PublicMethod
+#	define abstract
+#	define innerIf_ innerif_
+#	define emptySwitch emptyswitch
+#	define defaultSwitch defaultswitch
+#endif
+#if PHP_VERSION >= 520
+#else
+#	define __callStatic __callstatic
+#	define __toString __tostring
+#endif
+#if PHP_VERSION >= 530
+
+namespace ns;
+#define _Exception \Exception
+#endif
+
+abstract class ClassName
+{
+#if PHP_VERSION >= 500
+	const CONST_VALUE = 'A constant value';
+
+	/** doc */
+	static public $static = array(
+		0           => array('array'),
+		1           => 'str',
+		CONST_VALUE => CONST_VALUE
+		);
+	static public $classProp;
+	static public $static_const1 = CONST_VALUE;
+	static public $static_const2 = self::CONST_VALUE;
+	static public $static_const3 = ClassName::CONST_VALUE;
+	static public $static_const4 = array(CONST_VALUE => 'test');
+	static public $static_const5 = array(self::CONST_VALUE => 'test');
+	static public $static_const6 = array(ClassName::CONST_VALUE => 'test');
+	static public $static_const7 = array('test' => CONST_VALUE);
+	static public $static_const8 = array('test' => self::CONST_VALUE);
+	static public $static_const9 = array('test' => ClassName::CONST_VALUE);
+	static public $static_const10 = array(CONST_VALUE => CONST_VALUE);
+	static public $static_const11 = array(self::CONST_VALUE => self::CONST_VALUE);
+	static public $static_const12 = array(ClassName::CONST_VALUE => ClassName::CONST_VALUE);
+	/** doc */
+	static public $public_static = array(2, 'str');
+	/** doc */
+	static private $private_static = array(2, 'str');
+	static private $private_static2 = array(self::CONST_VALUE => self::CONST_VALUE);
+	/** doc */
+	static protected $protected_static = array(2, 'str');
+	static protected $protected_static2 = array(self::CONST_VALUE => self::CONST_VALUE);
+	/** doc */
+	public $property = array(
+		array('array'),
+		'str'
+		);
+	/** doc */
+	public $public_property = array(2, 'str');
+	/** doc */
+	private $private_property = array(2, 'str');
+	/** doc */
+	protected $protected_property = array(2, 'str');
+	public $array = array();
+#else
+	var $property = array(
+		array('array'),
+		'str'
+		);
+#endif
+
+#if PHP_VERSION >= 500
+	/** doc */
+#endif
+	PublicMethod function f1()
+	{
+	}
+
+	PublicMethod function f2()
+	{
+	}
+
+	PublicMethod function __construct($arg1, $arg2)
+	{
+		static $array = array(
+			0           => array('array'),
+			1           => 'str',
+			CONST_VALUE => CONST_VALUE
+			);
+		static $static = 1;
+		static $str = 'string';
+		echo CONST_VALUE;
+#if PHP_VERSION >= 500
+		echo ClassName::CONST_VALUE;
+		empty(ClassName::$classProp);
+		isset(ClassName::$classProp);
+		ClassName::$classProp = 1;
+		echo ClassName::$classProp;
+#endif
+		$object = $this;
+		$object->a = 1;
+		$object->b = 2;
+		$object->prop = 'prop';
+		empty($object->objProp);
+		isset($object->objProp);
+#if PHP_VERSION >= 500
+		unset($object->objProp);
+#endif
+		$object->objProp = 1;
+		echo $object->objProp;
+		empty($this->thisProp);
+		isset($this->thisProp);
+#if PHP_VERSION >= 500
+		unset($this->thisProp);
+#endif
+		$this->thisProp = 1;
+		echo $this->thisProp;
+#if PHP_VERSION >= 500
+		unset($array['index']->valueProp);
+#endif
+		unset($object->array['index']);
+		unset($this->array['index']);
+		empty($_GET['get']);
+		isset($_GET['get']);
+		unset($_GET['get']);
+		$_GET['get'] = 1;
+		echo $_GET['get'];
+		isset($GLOBALS['global']);
+		empty($GLOBALS['global']);
+		unset($GLOBALS['global']);
+		$GLOBALS['global'] = 1;
+		echo $GLOBALS['global'];
+		empty($array['index']);
+		isset($array['index']);
+		unset($array['index']);
+		$array['index'] = 1;
+		echo $array['index'];
+		empty($array['index']->indexProp);
+		isset($array['index']->indexProp);
+#if PHP_VERSION >= 500
+		unset($array['index']->indexProp);
+#endif
+		$array['index'] = $object;
+		$array['index']->indexProp = 1;
+		echo $array['index']->indexProp;
+		$GLOBALS['var'] = $object;
+		empty($GLOBALS['var']->indexProp);
+		isset($GLOBALS['var']->indexProp);
+#if PHP_VERSION >= 500
+		unset($GLOBALS['var']->indexProp);
+#endif
+		$GLOBALS['var']->indexProp = 1;
+		echo $GLOBALS['var']->indexProp;
+
+		if (0) {
+			ClassName::__construct();
+		}
+
+		$method = 'method';
+		ClassName::$method();
+		echo __CLASS__;
+		echo __METHOD__;
+		echo __FUNCTION__;
+		$this->method();
+
+#if PHP_VERSION >= 500
+		try {
+			throw new _Exception();
+			new _Exception();
+		}
+		catch (_Exception $e) {
+		}
+#endif
+
+		$a = 1;
+		$b = $c = 2;
+		$a = $b + $c;
+		$a = $b + 1;
+		$a = 1 + $b;
+		$a = $b - $c;
+		$a = $b * $c;
+		$a = $b / $c;
+		$a = $b % $c;
+		$a = $b . $c;
+		$a = $b = $c;
+		$a = $b & $c;
+		$a = $b | $c;
+		$a = $b ^ $c;
+		$a = ~$b;
+		$a = -$b;
+		$a = +$b;
+		$a = $b >> $c;
+		$a = $b >> $c;
+		$a = $b == $c;
+		$a = $b === $c;
+		$a = $b != $c;
+		$a = $b < $c;
+		$a = $b <= $c;
+		$a = $b <= $c;
+		$a = $b++;
+		$a = ++$b;
+		$a = $object->b++;
+		$a = ++$object->b;
+		$a = $b--;
+		$a = --$b;
+		$a = $object->b--;
+		$a = --$object->b;
+		$a = !$b;
+		$a = $b === $c;
+		$a = $b !== $c;
+		$a = $b << 2;
+		$a = $b >> 3;
+		$a += $b;
+		$a -= $b;
+		$a *= $b;
+		$a /= $b;
+		$a <<= $b;
+		$a >>= $b;
+		$a &= $b;
+		$a |= $b;
+		$a .= $b;
+		$a %= $b;
+		$a ^= $b;
+		$a = 'a' . 'b';
+		$a = 'a' . 'abc';
+		@f1();
+		print('1');
+		$array = array('index' => 1);
+		$a = $array['index'];
+		$a = $object->prop;
+		$a = $this->prop;
+		$array['index'] = 1;
+		$object->prop = 1;
+		$this->prop = 1;
+		$a = isset($b);
+		$a = empty($b);
+		unset($b);
+		$b = 1;
+		$a = isset($array['index']);
+		$a = empty($array['index']);
+		unset($array['index']);
+		$a = isset($object->prop);
+		$a = empty($object->prop);
+#if PHP_VERSION >= 500
+		unset($object->prop);
+#endif
+		$a = isset($this->prop);
+		$a = empty($this->prop);
+#if PHP_VERSION >= 500
+		unset($this->prop);
+		$a = isset(ClassName::$prop);
+		$a = empty(ClassName::$prop);
+#endif
+		$a = (int) $b;
+		$a = (double) $b;
+		$a = (string) $b;
+		$a = (array) $b;
+		$a = (object) $b;
+		$a = (bool) $b;
+		$a = (unset) $b;
+		$a = (array) $b;
+		$a = (object) $b;
+		$a = ($b ? $c : $d);
+		$a = (f1() ? f2() : f3());
+		($a = $b) xor $c;
+		($a = $b) and $c;
+		($a = $b) or $c;
+		$a = $b && $c;
+		$a = $b || $c;
+#if PHP_VERSION >= 530
+		echo $this::CONST_VALUE;
+		echo $object::CONST_VALUE;
+		echo CONST_VALUE;
+		$this::method();
+		$object::method();
+		$a = $b ?: $d;
+		$a = ($b ?: $d) + $c;
+		$a = f1() ?: f2();
+		$a = ClassName::f1() ?: ClassName::f2();
+		$a = ($b ? $c : $d);
+		$a = ($b ? $c : $d) + $c;
+		$a = (f1() ? f3() : f2());
+
+		if ($b ?: $d) {
+			echo 'if ($b ?: $d)';
+		}
+
+		if (($b ?: $d) + $c) {
+			echo 'if (($b ?: $d) + $c)';
+		}
+
+		if (f1() ?: f2()) {
+			echo 'if (f1() ?: f2())';
+		}
+#endif
+	}
+
+	public function __destruct()
+	{
+	}
+#if PHP_VERSION >= 500
+
+	/** doc */
+	abstract public function abstractMethod();
+#endif
+
+#if PHP_VERSION >= 500
+	/** doc */
+#endif
+	PublicMethod function method($a = NULL, $b = NULL)
+	{
+	}
+#if PHP_VERSION >= 500
+
+	/** doc */
+	protected function protectedMethod(ClassName $a, $b = array(
+			array('array')
+			))
+	{
+		$runtimeArray = array('1');
+		$runtimeArray2 = array(
+			'1',
+			array()
+			);
+		$runtimeArray3 = array(
+			'a' => '1',
+			2   => array()
+			);
+		return 'protected';
+	}
+
+	/** doc */
+	private function privateMethod(ClassName $a, $b = NULL)
+	{
+		return 'private';
+	}
+#endif
+}
+#if PHP_VERSION >= 500
+
+interface IInterface
+{
+	public function nothing();
+}
+#endif
+
+function f1()
+{
+}
+
+function f2()
+{
+}
+
+function f3()
+{
+}
+
+function generator($f)
+{
+	echo __FUNCTION__;
+	echo $f;
+#if PHP_VERSION >= 550
+
+	foreach ($a as $b) {
+		yield $b;
+	}
+
+	yield f1($b);
+#endif
+}
+#if PHP_VERSION >= 500
+
+final class Child extends ClassName implements IInterface
+{
+	public function __construct()
+	{
+		parent::__construct('a', 'b');
+	}
+
+	public function __destruct()
+	{
+		parent::__destruct();
+	}
+
+	static public function __callStatic($name, $args)
+	{
+		parent::__callStatic($name, $args);
+	}
+
+	public function abstractMethod()
+	{
+	}
+
+	public function nothing()
+	{
+	}
+
+	public function __toString()
+	{
+		parent::__toString();
+	}
+
+	public function __set($name, $value)
+	{
+	}
+
+	public function __get($name)
+	{
+	}
+
+	public function __isset($name)
+	{
+	}
+
+	public function __unset($name)
+	{
+	}
+
+	public function __sleep()
+	{
+	}
+
+	public function __wakeup()
+	{
+	}
+
+	public function __clone()
+	{
+		return array();
+	}
+}
+#endif
+
+define('CONST_VALUE', 'const value');
+$late = isset($_ENV['LATE']);
+
+if ($late) {
+	class LateBindingClass
+	{
+		PublicMethod function __construct()
+		{
+		}
+	}
+
+	function lateBindingFunction($arg)
+	{
+		echo 'lateFunction';
+		return new lateBindingFunction();
+	}
+}
+
+echo "\r\n";
+echo "\r";
+echo "\n";
+var_dump(array('a' => 'a', 'b' => 'c'), 'b');
+$object = new Child();
+$className = 'ns\\Child';
+$object = new $className();
+#if PHP_VERSION >= 500
+$result = $object instanceof Child;
+$cloned = clone $object;
+#endif
+#if PHP_VERSION >= 500
+
+do {
+	try {
+		echo 'outer try 1';
+
+		try {
+			echo 'inner try';
+		}
+		catch (InnerException $e) {
+			echo $e;
+		}
+		catch (InnerException2 $e2) {
+			echo $e2;
+		}
+#if PHP_VERSION >= 550
+		finally {
+			echo 'inner finally';
+		}
+#endif
+
+		echo 'outer try 2';
+	}
+	catch (OuterException $e) {
+		echo $e;
+	}
+	catch (OuterException2 $e2) {
+		echo $e2;
+	}
+#if PHP_VERSION >= 550
+	finally {
+		echo 'outer finally';
+	}
+#endif
+} while (0);
+#endif
+
+if ('if()') {
+	echo 'if';
+
+	if ('innerIf()') {
+		echo 'if innerIf';
+	}
+}
+else if ('elseif_()') {
+	echo 'else if';
+
+	if ('innerIf_()') {
+		echo 'if innerIf';
+	}
+}
+else {
+	if ('innerIf_()') {
+		echo 'if innerIf';
+	}
+
+	echo 'else';
+}
+
+while (false) {
+	echo 'while';
+}
+
+do {
+	echo 'do/while';
+} while (false);
+
+$i = 1;
+
+for (; $i < 10; ++$i) {
+	echo $i;
+	break;
+}
+
+$array = array(
+	array('a' => 'b')
+	);
+
+foreach ($array as $value) {
+	foreach ($value as $key => $value) {
+		echo $key . ' = ' . $value . "\n";
+		break 2;
+		continue;
+	}
+}
+
+switch ('$normalSwitch') {
+case 'case1':
+	echo 'case1';
+
+	switch ('$nestedSwitch') {
+	case 1:
+	}
+
+	break;
+
+case 'case2':
+	echo 'case2';
+	break;
+
+default:
+	switch ('$nestedSwitch') {
+	case 1:
+	}
+
+	echo 'default';
+	break;
+}
+
+switch ('$switchWithoutDefault') {
+case 'case1':
+	echo 'case1';
+	break;
+
+case 'case2':
+	echo 'case2';
+	break;
+}
+
+switch ('$switchWithMiddleDefault') {
+case 'case1':
+	echo 'case1';
+	break;
+
+default:
+	echo 'default';
+	break;
+
+case 'case2':
+	echo 'case2';
+	break;
+}
+
+switch ('$switchWithInitialDefault') {
+default:
+	echo 'default';
+	break;
+
+case 'case1':
+	echo 'case1';
+	break;
+
+case 'case2':
+	echo 'case2';
+	break;
+}
+
+switch ('emptySwitch()') {
+}
+
+switch ('defaultSwitch()') {
+default:
+}
+
+declare (ticks=1) {
+	echo 1;
+}
+
+$a = true;
+
+while ($a) {
+	declare (ticks=1) {
+		echo 2;
+	}
+
+	$a = false;
+}
+
+require 'require.php';
+require_once 'require_once.php';
+include 'include.php';
+include_once 'include_once.php';
+echo __FILE__;
+echo __LINE__;
+#if PHP_VERSION >= 530
+echo 'goto a';
+goto a;
+
+$i = 1;
+
+for (; $i <= 2; ++$i) {
+	goto a;
+}
+
+a:
+echo 'label a';
+echo preg_replace_callback('~-([a-z])~', function($match) {
+	return strtoupper($match[1]);
+}, 'hello-world');
+$greet = function($name) {
+	printf('Hello %s' . "\r\n" . '', $name);
+};
+$greet('World');
+$greet('PHP');
+$total = 0;
+$tax = 1;
+$callback = function($quantity, $product) use($tax, &$total) {
+	$tax = 'tax';
+	static $static1 = array(1);
+	static $static2;
+	$tax = 'tax';
+	$tax = --$tax;
+	$pricePerItem = constant('PRICE_' . strtoupper($product));
+	$total += $pricePerItem * $quantity * ($tax + 1);
+};
+#endif
+exit();
+
+?>
--- xcache.orig/lib/Decompiler.class.php
+++ xcache/lib/Decompiler.class.php
@@ -2796,7 +2796,9 @@ class Decompiler
 }
 
 // {{{ defines
-define('ZEND_ENGINE_2_4', PHP_VERSION >= "5.4");
+define('ZEND_ENGINE_2_6', PHP_VERSION >= "5.6");
+define('ZEND_ENGINE_2_5', ZEND_ENGINE_2_6 || PHP_VERSION >= "5.5.");
+define('ZEND_ENGINE_2_4', ZEND_ENGINE_2_5 || PHP_VERSION >= "5.4.");
 define('ZEND_ENGINE_2_3', ZEND_ENGINE_2_4 || PHP_VERSION >= "5.3.");
 define('ZEND_ENGINE_2_2', ZEND_ENGINE_2_3 || PHP_VERSION >= "5.2.");
 define('ZEND_ENGINE_2_1', ZEND_ENGINE_2_2 || PHP_VERSION >= "5.1.");
@@ -2925,7 +2927,13 @@ define('IS_OBJECT',   5);
 define('IS_STRING',   ZEND_ENGINE_2_1 ? 6 : 3);
 define('IS_RESOURCE', 7);
 define('IS_CONSTANT', 8);
-define('IS_CONSTANT_ARRAY',   9);
+if (ZEND_ENGINE_2_6) {
+	define('IS_CONSTANT_ARRAY', -1);
+	define('IS_CONSTANT_AST', 9);
+}
+else {
+	define('IS_CONSTANT_ARRAY', 9);
+}
 if (ZEND_ENGINE_2_4) {
 	define('IS_CALLABLE', 10);
 }
--- xcache.orig/xcache/xc_compatibility.h
+++ xcache/xcache/xc_compatibility.h
@@ -10,7 +10,10 @@
 /* Purpose: Privode stuffs for compatibility with different PHP version
  */
 
-#if !defined(ZEND_ENGINE_2_5) && (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 5 || PHP_MAJOR_VERSION > 6)
+#if !defined(ZEND_ENGINE_2_6) && (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION >= 6 || PHP_MAJOR_VERSION > 6)
+#	define ZEND_ENGINE_2_6
+#endif
+#if !defined(ZEND_ENGINE_2_5) && (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION == 5 || defined(ZEND_ENGINE_2_6))
 #	define ZEND_ENGINE_2_5
 #endif
 #if !defined(ZEND_ENGINE_2_4) && (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION == 4 || defined(ZEND_ENGINE_2_5))
--- xcache.orig/xcache/xc_const_string.c
+++ xcache/xcache/xc_const_string.c
@@ -71,6 +71,8 @@ const char *xc_get_data_type(zend_uchar
 /* {{{ xc_get_opcode */
 #if PHP_MAJOR_VERSION >= 6
 #	include "xc_const_string_opcodes_php6.x.h"
+#elif defined(ZEND_ENGINE_2_6)
+#	include "xc_const_string_opcodes_php5.6.h"
 #elif defined(ZEND_ENGINE_2_5)
 #	include "xc_const_string_opcodes_php5.5.h"
 #elif defined(ZEND_ENGINE_2_4)
--- /dev/null
+++ xcache/xcache/xc_const_string_opcodes_php5.6.h
@@ -0,0 +1,171 @@
+/* size = 168 */
+static const char *const xc_opcode_names[] = {
+/* 0 */	"NOP",
+/* 1 */	"ADD",
+/* 2 */	"SUB",
+/* 3 */	"MUL",
+/* 4 */	"DIV",
+/* 5 */	"MOD",
+/* 6 */	"SL",
+/* 7 */	"SR",
+/* 8 */	"CONCAT",
+/* 9 */	"BW_OR",
+/* 10 */	"BW_AND",
+/* 11 */	"BW_XOR",
+/* 12 */	"BW_NOT",
+/* 13 */	"BOOL_NOT",
+/* 14 */	"BOOL_XOR",
+/* 15 */	"IS_IDENTICAL",
+/* 16 */	"IS_NOT_IDENTICAL",
+/* 17 */	"IS_EQUAL",
+/* 18 */	"IS_NOT_EQUAL",
+/* 19 */	"IS_SMALLER",
+/* 20 */	"IS_SMALLER_OR_EQUAL",
+/* 21 */	"CAST",
+/* 22 */	"QM_ASSIGN",
+/* 23 */	"ASSIGN_ADD",
+/* 24 */	"ASSIGN_SUB",
+/* 25 */	"ASSIGN_MUL",
+/* 26 */	"ASSIGN_DIV",
+/* 27 */	"ASSIGN_MOD",
+/* 28 */	"ASSIGN_SL",
+/* 29 */	"ASSIGN_SR",
+/* 30 */	"ASSIGN_CONCAT",
+/* 31 */	"ASSIGN_BW_OR",
+/* 32 */	"ASSIGN_BW_AND",
+/* 33 */	"ASSIGN_BW_XOR",
+/* 34 */	"PRE_INC",
+/* 35 */	"PRE_DEC",
+/* 36 */	"POST_INC",
+/* 37 */	"POST_DEC",
+/* 38 */	"ASSIGN",
+/* 39 */	"ASSIGN_REF",
+/* 40 */	"ECHO",
+/* 41 */	"PRINT",
+/* 42 */	"JMP",
+/* 43 */	"JMPZ",
+/* 44 */	"JMPNZ",
+/* 45 */	"JMPZNZ",
+/* 46 */	"JMPZ_EX",
+/* 47 */	"JMPNZ_EX",
+/* 48 */	"CASE",
+/* 49 */	"SWITCH_FREE",
+/* 50 */	"BRK",
+/* 51 */	"CONT",
+/* 52 */	"BOOL",
+/* 53 */	"INIT_STRING",
+/* 54 */	"ADD_CHAR",
+/* 55 */	"ADD_STRING",
+/* 56 */	"ADD_VAR",
+/* 57 */	"BEGIN_SILENCE",
+/* 58 */	"END_SILENCE",
+/* 59 */	"INIT_FCALL_BY_NAME",
+/* 60 */	"DO_FCALL",
+/* 61 */	"DO_FCALL_BY_NAME",
+/* 62 */	"RETURN",
+/* 63 */	"RECV",
+/* 64 */	"RECV_INIT",
+/* 65 */	"SEND_VAL",
+/* 66 */	"SEND_VAR",
+/* 67 */	"SEND_REF",
+/* 68 */	"NEW",
+/* 69 */	"INIT_NS_FCALL_BY_NAME",
+/* 70 */	"FREE",
+/* 71 */	"INIT_ARRAY",
+/* 72 */	"ADD_ARRAY_ELEMENT",
+/* 73 */	"INCLUDE_OR_EVAL",
+/* 74 */	"UNSET_VAR",
+/* 75 */	"UNSET_DIM",
+/* 76 */	"UNSET_OBJ",
+/* 77 */	"FE_RESET",
+/* 78 */	"FE_FETCH",
+/* 79 */	"EXIT",
+/* 80 */	"FETCH_R",
+/* 81 */	"FETCH_DIM_R",
+/* 82 */	"FETCH_OBJ_R",
+/* 83 */	"FETCH_W",
+/* 84 */	"FETCH_DIM_W",
+/* 85 */	"FETCH_OBJ_W",
+/* 86 */	"FETCH_RW",
+/* 87 */	"FETCH_DIM_RW",
+/* 88 */	"FETCH_OBJ_RW",
+/* 89 */	"FETCH_IS",
+/* 90 */	"FETCH_DIM_IS",
+/* 91 */	"FETCH_OBJ_IS",
+/* 92 */	"FETCH_FUNC_ARG",
+/* 93 */	"FETCH_DIM_FUNC_ARG",
+/* 94 */	"FETCH_OBJ_FUNC_ARG",
+/* 95 */	"FETCH_UNSET",
+/* 96 */	"FETCH_DIM_UNSET",
+/* 97 */	"FETCH_OBJ_UNSET",
+/* 98 */	"FETCH_DIM_TMP_VAR",
+/* 99 */	"FETCH_CONSTANT",
+/* 100 */	"GOTO",
+/* 101 */	"EXT_STMT",
+/* 102 */	"EXT_FCALL_BEGIN",
+/* 103 */	"EXT_FCALL_END",
+/* 104 */	"EXT_NOP",
+/* 105 */	"TICKS",
+/* 106 */	"SEND_VAR_NO_REF",
+/* 107 */	"CATCH",
+/* 108 */	"THROW",
+/* 109 */	"FETCH_CLASS",
+/* 110 */	"CLONE",
+/* 111 */	"RETURN_BY_REF",
+/* 112 */	"INIT_METHOD_CALL",
+/* 113 */	"INIT_STATIC_METHOD_CALL",
+/* 114 */	"ISSET_ISEMPTY_VAR",
+/* 115 */	"ISSET_ISEMPTY_DIM_OBJ",
+/* 116 */	"UNDEF",
+/* 117 */	"UNDEF",
+/* 118 */	"UNDEF",
+/* 119 */	"UNDEF",
+/* 120 */	"UNDEF",
+/* 121 */	"UNDEF",
+/* 122 */	"UNDEF",
+/* 123 */	"UNDEF",
+/* 124 */	"UNDEF",
+/* 125 */	"UNDEF",
+/* 126 */	"UNDEF",
+/* 127 */	"UNDEF",
+/* 128 */	"UNDEF",
+/* 129 */	"UNDEF",
+/* 130 */	"UNDEF",
+/* 131 */	"UNDEF",
+/* 132 */	"PRE_INC_OBJ",
+/* 133 */	"PRE_DEC_OBJ",
+/* 134 */	"POST_INC_OBJ",
+/* 135 */	"POST_DEC_OBJ",
+/* 136 */	"ASSIGN_OBJ",
+/* 137 */	"OP_DATA",
+/* 138 */	"INSTANCEOF",
+/* 139 */	"DECLARE_CLASS",
+/* 140 */	"DECLARE_INHERITED_CLASS",
+/* 141 */	"DECLARE_FUNCTION",
+/* 142 */	"RAISE_ABSTRACT_ERROR",
+/* 143 */	"DECLARE_CONST",
+/* 144 */	"ADD_INTERFACE",
+/* 145 */	"DECLARE_INHERITED_CLASS_DELAYED",
+/* 146 */	"VERIFY_ABSTRACT_CLASS",
+/* 147 */	"ASSIGN_DIM",
+/* 148 */	"ISSET_ISEMPTY_PROP_OBJ",
+/* 149 */	"HANDLE_EXCEPTION",
+/* 150 */	"USER_OPCODE",
+/* 151 */	"UNDEF",
+/* 152 */	"JMP_SET",
+/* 153 */	"DECLARE_LAMBDA_FUNCTION",
+/* 154 */	"ADD_TRAIT",
+/* 155 */	"BIND_TRAITS",
+/* 156 */	"SEPARATE",
+/* 157 */	"QM_ASSIGN_VAR",
+/* 158 */	"JMP_SET_VAR",
+/* 159 */	"DISCARD_EXCEPTION",
+/* 160 */	"YIELD",
+/* 161 */	"GENERATOR_RETURN",
+/* 162 */	"FAST_CALL",
+/* 163 */	"FAST_RET",
+/* 164 */	"RECV_VARIADIC",
+/* 165 */	"SEND_UNPACK",
+/* 166 */	"POW",
+/* 167 */	"ASSIGN_POW"
+};
--- xcache.orig/xcache/xc_malloc.c
+++ xcache/xcache/xc_malloc.c
@@ -1,5 +1,7 @@
-#define XC_SHM_IMPL _xc_malloc_shm_t
+typedef struct xc_malloc_shm_t xc_shm_t;
+#define XC_SHM_T_DEFINED
 #define _xc_allocator_t _xc_allocator_malloc_t
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -18,11 +20,11 @@ struct _xc_allocator_malloc_t {
 	xc_memsize_t avail;       /* total free */
 };
 
-/* {{{ _xc_malloc_shm_t */
-struct _xc_malloc_shm_t {
-	xc_shm_handlers_t *handlers;
-	xc_shmsize_t       size;
-	xc_shmsize_t       memoffset;
+/* {{{ xc_malloc_shm_t */
+struct xc_malloc_shm_t {
+	xc_shm_vtable_t *vtable;
+	xc_shmsize_t     size;
+	xc_shmsize_t     memoffset;
 #ifndef TEST
 	HashTable blocks;
 #endif
@@ -138,25 +140,45 @@ static XC_ALLOCATOR_DESTROY(xc_allocator
 }
 /* }}} */
 
-static XC_SHM_CAN_READONLY(xc_malloc_can_readonly) /* {{{ */
+static XC_SHM_DESTROY(xc_malloc_destroy) /* {{{ */
 {
-	return 0;
+#ifndef TEST
+	zend_hash_destroy(&shm->blocks);
+#endif
+	free(shm);
+	return;
+}
+/* }}} */
+static XC_SHM_INIT(xc_malloc_init) /* {{{ */
+{
+	xc_shm_t *shm;
+	CHECK(shm = calloc(1, sizeof(xc_shm_t)), "shm OOM");
+	shm->size = size;
+
+#ifndef TEST
+	zend_hash_init(&shm->blocks, 64, NULL, NULL, 1);
+#endif
+	return shm;
+err:
+	return NULL;
 }
 /* }}} */
+
 static XC_SHM_IS_READWRITE(xc_malloc_is_readwrite) /* {{{ */
 {
 #ifndef TEST
 	HashPosition pos;
 	size_t *psize;
 	char **ptr;
+	HashTable *blocks = &((xc_shm_t *) shm)->blocks;
 
-	zend_hash_internal_pointer_reset_ex(&shm->blocks, &pos);
-	while (zend_hash_get_current_data_ex(&shm->blocks, (void **) &psize, &pos) == SUCCESS) {
-		zend_hash_get_current_key_ex(&shm->blocks, (void *) &ptr, NULL, NULL, 0, &pos);
+	zend_hash_internal_pointer_reset_ex(blocks, &pos);
+	while (zend_hash_get_current_data_ex(blocks, (void **) &psize, &pos) == SUCCESS) {
+		zend_hash_get_current_key_ex(blocks, (void *) &ptr, NULL, NULL, 0, &pos);
 		if ((char *) p >= *ptr && (char *) p < *ptr + *psize) {
 			return 1;
 		}
-		zend_hash_move_forward_ex(&shm->blocks, &pos);
+		zend_hash_move_forward_ex(blocks, &pos);
 	}
 #endif
 
@@ -168,40 +190,6 @@ static XC_SHM_IS_READONLY(xc_malloc_is_r
 	return 0;
 }
 /* }}} */
-static XC_SHM_TO_READWRITE(xc_malloc_to_readwrite) /* {{{ */
-{
-	return p;
-}
-/* }}} */
-static XC_SHM_TO_READONLY(xc_malloc_to_readonly) /* {{{ */
-{
-	return p;
-}
-/* }}} */
-
-static XC_SHM_DESTROY(xc_malloc_destroy) /* {{{ */
-{
-#ifndef TEST
-	zend_hash_destroy(&shm->blocks);
-#endif
-	free(shm);
-	return;
-}
-/* }}} */
-static XC_SHM_INIT(xc_malloc_init) /* {{{ */
-{
-	xc_shm_t *shm;
-	CHECK(shm = calloc(1, sizeof(xc_shm_t)), "shm OOM");
-	shm->size = size;
-
-#ifndef TEST
-	zend_hash_init(&shm->blocks, 64, NULL, NULL, 1);
-#endif
-	return shm;
-err:
-	return NULL;
-}
-/* }}} */
 
 static XC_SHM_MEMINIT(xc_malloc_meminit) /* {{{ */
 {
@@ -227,7 +215,7 @@ static XC_SHM_MEMDESTROY(xc_malloc_memde
 
 static xc_allocator_vtable_t xc_allocator_malloc_vtable = XC_ALLOCATOR_VTABLE(allocator_malloc);
 #ifndef TEST
-static xc_shm_handlers_t xc_shm_malloc_handlers = XC_SHM_HANDLERS(malloc);
+static xc_shm_vtable_t xc_shm_malloc_vtable = XC_SHM_VTABLE(malloc);
 #endif
 void xc_allocator_malloc_register() /* {{{ */
 {
@@ -242,7 +230,7 @@ void xc_allocator_malloc_register() /* {
 #ifndef TEST
 void xc_shm_malloc_register() /* {{{ */
 {
-	if (xc_shm_scheme_register("malloc", &xc_shm_malloc_handlers) == 0) {
+	if (xc_shm_scheme_register("malloc", &xc_shm_malloc_vtable) == 0) {
 		zend_error(E_ERROR, "XCache: failed to register malloc shm_scheme");
 	}
 }
--- xcache.orig/xcache/xc_opcode_spec_def.h
+++ xcache/xcache/xc_opcode_spec_def.h
@@ -300,4 +300,10 @@ static const xc_opcode_spec_t xc_opcode_
 	OPSPEC(    UNUSED,    JMPADDR,     UNUSED,     UNUSED) /* 162 FAST_CALL                      */
 	OPSPEC(    UNUSED,     UNUSED,     UNUSED,     UNUSED) /* 163 FAST_RET                       */
 #endif
+#ifdef ZEND_ENGINE_2_6
+	OPSPEC(    UNUSED,        ARG,     UNUSED,        VAR) /* 164 RECV_VARIADIC                  */
+	OPSPEC(      SEND,        STD,        ARG,     UNUSED) /* 165 SEND_UNPACK                    */
+	OPSPEC(    UNUSED,        STD,        STD,        TMP) /* 166 POW                            */
+	OPSPEC(    ASSIGN,        STD,        STD,        VAR) /* 167 ASSIGN_POW                     */
+#endif
 };
--- xcache.orig/xcache/xc_sandbox.c
+++ xcache/xcache/xc_sandbox.c
@@ -163,6 +163,7 @@ static xc_sandbox_t *xc_sandbox_init(xc_
 
 	OG(function_table) = CG(function_table);
 	CG(function_table) = &TG(function_table);
+	EG(function_table) = CG(function_table);
 
 	OG(class_table) = CG(class_table);
 	CG(class_table) = &TG(class_table);
@@ -331,6 +332,7 @@ static void xc_sandbox_free(xc_sandbox_t
 	EG(zend_constants) = OG(zend_constants);
 #endif
 	CG(function_table) = OG(function_table);
+	EG(function_table) = CG(function_table);
 	CG(class_table)    = OG(class_table);
 	EG(class_table)    = CG(class_table);
 #ifdef ZEND_ENGINE_2_1
--- xcache.orig/xcache/xc_shm.c
+++ xcache/xcache/xc_shm.c
@@ -14,8 +14,8 @@
 #include <string.h>
 
 struct _xc_shm_scheme_t {
-	const char              *name;
-	const xc_shm_handlers_t *handlers;
+	const char            *name;
+	const xc_shm_vtable_t *vtable;
 };
 static xc_shm_scheme_t xc_shm_schemes[10];
 
@@ -35,25 +35,25 @@ void xc_shm_init_modules() /* {{{ */
 	xc_shm_mmap_register();
 }
 /* }}} */
-int xc_shm_scheme_register(const char *name, const xc_shm_handlers_t *handlers) /* {{{ */
+int xc_shm_scheme_register(const char *name, const xc_shm_vtable_t *vtable) /* {{{ */
 {
 	int i;
 	for (i = 0; i < 10; i ++) {
 		if (!xc_shm_schemes[i].name) {
 			xc_shm_schemes[i].name = name;
-			xc_shm_schemes[i].handlers = handlers;
+			xc_shm_schemes[i].vtable = vtable;
 			return 1;
 		}
 	}
 	return 0;
 }
 /* }}} */
-const xc_shm_handlers_t *xc_shm_scheme_find(const char *name) /* {{{ */
+const xc_shm_vtable_t *xc_shm_scheme_find(const char *name) /* {{{ */
 {
 	int i;
 	for (i = 0; i < 10 && xc_shm_schemes[i].name; i ++) {
 		if (strcmp(xc_shm_schemes[i].name, name) == 0) {
-			return xc_shm_schemes[i].handlers;
+			return xc_shm_schemes[i].vtable;
 		}
 	}
 	return NULL;
@@ -78,12 +78,12 @@ const char *xc_shm_scheme_name(xc_shm_sc
 /* }}} */
 xc_shm_t *xc_shm_init(const char *type, xc_shmsize_t size, int readonly_protection, const void *arg1, const void *arg2) /* {{{ */
 {
-	const xc_shm_handlers_t *handlers = xc_shm_scheme_find(type);
+	const xc_shm_vtable_t *vtable = xc_shm_scheme_find(type);
 
-	if (handlers) {
-		xc_shm_t *shm = handlers->init(size, readonly_protection, arg1, arg2);
+	if (vtable) {
+		xc_shm_t *shm = vtable->init(size, readonly_protection, arg1, arg2);
 		if (shm) {
-			shm->handlers = handlers;
+			shm->vtable = vtable;
 		}
 		return shm;
 	}
@@ -93,6 +93,36 @@ xc_shm_t *xc_shm_init(const char *type,
 /* }}} */
 void xc_shm_destroy(xc_shm_t *shm) /* {{{ */
 {
-	shm->handlers->destroy(shm);
+	shm->vtable->destroy(shm);
+}
+/* }}} */
+
+int xc_shm_can_readonly(const xc_shm_t *shm) /* {{{ */
+{
+	return ((xc_shm_base_t *)shm)->readonlydiff != 0;
+}
+/* }}} */
+void *xc_shm_to_readwrite(const xc_shm_t *shm_, void *p) /* {{{ */
+{
+	const xc_shm_base_t *shm = (const xc_shm_base_t *) shm_;
+
+	if (shm->readonlydiff) {
+		assert(shm->vtable->is_readonly(shm_, p));
+		p = ((char *) p) - shm->readonlydiff;
+	}
+	assert(shm->vtable->is_readwrite(shm_, p));
+	return p;
+}
+/* }}} */
+void *xc_shm_to_readonly(const xc_shm_t *shm_, void *p) /* {{{ */
+{
+	const xc_shm_base_t *shm = (const xc_shm_base_t *) shm_;
+
+	assert(shm->vtable->is_readwrite(shm_, p));
+	if (shm->readonlydiff) {
+		p = ((char *) p) + shm->readonlydiff;
+		assert(shm->vtable->is_readonly(shm_, p));
+	}
+	return p;
 }
 /* }}} */
--- xcache.orig/xcache/xc_shm.h
+++ xcache/xcache/xc_shm.h
@@ -2,25 +2,26 @@
 #define XC_SHM_H
 
 #include <stdlib.h>
+#include <stddef.h>
+#include <assert.h>
 
-typedef struct _xc_shm_handlers_t xc_shm_handlers_t;
-
-#ifndef XC_SHM_IMPL
-struct _xc_shm_t {
-	const xc_shm_handlers_t *handlers;
-};
-#define XC_SHM_IMPL _xc_shm_t
+#ifndef XC_SHM_T_DEFINED
+typedef struct _xc_shm_base_t xc_shm_t;
+#define XC_SHM_T_DEFINED
 #endif
 
-typedef struct XC_SHM_IMPL xc_shm_t;
+typedef struct _xc_shm_vtable_t xc_shm_vtable_t;
+
+typedef struct _xc_shm_base_t {
+	const xc_shm_vtable_t *vtable;
+	ptrdiff_t readonlydiff;
+} xc_shm_base_t;
+
 typedef size_t xc_shmsize_t;
 
 /* shm */
-#define XC_SHM_CAN_READONLY(func) int   func(xc_shm_t *shm)
-#define XC_SHM_IS_READWRITE(func) int   func(xc_shm_t *shm, const void *p)
-#define XC_SHM_IS_READONLY(func)  int   func(xc_shm_t *shm, const void *p)
-#define XC_SHM_TO_READWRITE(func) void *func(xc_shm_t *shm, void *p)
-#define XC_SHM_TO_READONLY(func)  void *func(xc_shm_t *shm, void *p)
+#define XC_SHM_IS_READWRITE(func) int   func(const xc_shm_t *shm, const void *p)
+#define XC_SHM_IS_READONLY(func)  int   func(const xc_shm_t *shm, const void *p)
 
 #define XC_SHM_INIT(func)         xc_shm_t *func(xc_shmsize_t size, int readonly_protection, const void *arg1, const void *arg2)
 #define XC_SHM_DESTROY(func)      void func(xc_shm_t *shm)
@@ -28,28 +29,22 @@ typedef size_t xc_shmsize_t;
 #define XC_SHM_MEMINIT(func)      void *func(xc_shm_t *shm, xc_shmsize_t size)
 #define XC_SHM_MEMDESTROY(func)   void func(void *mem)
 
-#define XC_SHM_HANDLERS(name)    { \
-	xc_##name##_can_readonly       \
+#define XC_SHM_VTABLE(name)      { \
+	  xc_##name##_init             \
+	, xc_##name##_destroy          \
 	, xc_##name##_is_readwrite     \
 	, xc_##name##_is_readonly      \
-	, xc_##name##_to_readwrite     \
-	, xc_##name##_to_readonly      \
 \
-	, xc_##name##_init             \
-	, xc_##name##_destroy          \
 \
 	, xc_##name##_meminit          \
 	, xc_##name##_memdestroy       \
 }
 
-struct _xc_shm_handlers_t {
-	XC_SHM_CAN_READONLY((*can_readonly));
-	XC_SHM_IS_READWRITE((*is_readwrite));
-	XC_SHM_IS_READONLY((*is_readonly));
-	XC_SHM_TO_READWRITE((*to_readwrite));
-	XC_SHM_TO_READONLY((*to_readonly));
+struct _xc_shm_vtable_t {
 	XC_SHM_INIT((*init));
 	XC_SHM_DESTROY((*destroy));
+	XC_SHM_IS_READWRITE((*is_readwrite));
+	XC_SHM_IS_READONLY((*is_readonly));
 
 	XC_SHM_MEMINIT((*meminit));
 	XC_SHM_MEMDESTROY((*memdestroy));
@@ -58,12 +53,17 @@ struct _xc_shm_handlers_t {
 typedef struct _xc_shm_scheme_t xc_shm_scheme_t;
 
 void xc_shm_init_modules();
-int xc_shm_scheme_register(const char *name, const xc_shm_handlers_t *handlers);
-const xc_shm_handlers_t *xc_shm_scheme_find(const char *name);
+int xc_shm_scheme_register(const char *name, const xc_shm_vtable_t *vtable);
+const xc_shm_vtable_t *xc_shm_scheme_find(const char *name);
 xc_shm_scheme_t *xc_shm_scheme_first();
 xc_shm_scheme_t *xc_shm_scheme_next(xc_shm_scheme_t *scheme);
 const char *xc_shm_scheme_name(xc_shm_scheme_t *scheme);
 
 xc_shm_t *xc_shm_init(const char *type, xc_shmsize_t size, int readonly_protection, const void *arg1, const void *arg2);
 void xc_shm_destroy(xc_shm_t *shm);
+
+int xc_shm_can_readonly(const xc_shm_t *shm);
+void *xc_shm_to_readwrite(const xc_shm_t *shm_, void *p);
+void *xc_shm_to_readonly(const xc_shm_t *shm_, void *p);
+
 #endif
--- xcache.orig/xcache/xc_shm_mmap.c
+++ xcache/xcache/xc_shm_mmap.c
@@ -29,7 +29,9 @@
 #endif
 
 #include "php.h"
-#define XC_SHM_IMPL _xc_mmap_shm_t
+
+typedef struct xc_mmap_shm_t xc_shm_t;
+#define XC_SHM_T_DEFINED
 #include "xc_shm.h"
 #include "xc_utils.h"
 
@@ -38,12 +40,10 @@
 #endif
 
 /* {{{ xc_shm_t */
-struct _xc_mmap_shm_t {
-	xc_shm_handlers_t *handlers;
-	zend_bool disabled;
+struct xc_mmap_shm_t {
+	xc_shm_base_t base;
 	void *ptr;
 	void *ptr_ro;
-	long  diff;
 	xc_shmsize_t size;
 	xc_shmsize_t memoffset;
 	char *name;
@@ -60,11 +60,6 @@ struct _xc_mmap_shm_t {
 #define PTR_ADD(ptr, v) (((char *) (ptr)) + (v))
 #define PTR_SUB(ptr, v) (((char *) (ptr)) - (v))
 
-static XC_SHM_CAN_READONLY(xc_mmap_can_readonly) /* {{{ */
-{
-	return shm->ptr_ro != NULL;
-}
-/* }}} */
 static XC_SHM_IS_READWRITE(xc_mmap_is_readwrite) /* {{{ */
 {
 	return p >= shm->ptr && (char *)p < (char *)shm->ptr + shm->size;
@@ -72,27 +67,7 @@ static XC_SHM_IS_READWRITE(xc_mmap_is_re
 /* }}} */
 static XC_SHM_IS_READONLY(xc_mmap_is_readonly) /* {{{ */
 {
-	return xc_mmap_can_readonly(shm) && p >= shm->ptr_ro && (char *)p < (char *)shm->ptr_ro + shm->size;
-}
-/* }}} */
-static XC_SHM_TO_READWRITE(xc_mmap_to_readwrite) /* {{{ */
-{
-	if (shm->diff) {
-		assert(xc_mmap_is_readonly(shm, p));
-		p = PTR_SUB(p, shm->diff);
-	}
-	assert(xc_mmap_is_readwrite(shm, p));
-	return p;
-}
-/* }}} */
-static XC_SHM_TO_READONLY(xc_mmap_to_readonly) /* {{{ */
-{
-	assert(xc_mmap_is_readwrite(shm, p));
-	if (shm->diff) {
-		p = PTR_ADD(p, shm->diff);
-		assert(xc_mmap_is_readonly(shm, p));
-	}
-	return p;
+	return xc_shm_can_readonly(shm) && p >= shm->ptr_ro && (char *)p < (char *)shm->ptr_ro + shm->size;
 }
 /* }}} */
 
@@ -132,7 +107,7 @@ static XC_SHM_DESTROY(xc_mmap_destroy) /
 	}
 	/*
 	shm->size = NULL;
-	shm->diff = 0;
+	shm->base.readonlydiff = 0;
 	*/
 
 	free(shm);
@@ -242,9 +217,9 @@ static XC_SHM_INIT(xc_mmap_init) /* {{{
 		} while (0);
 
 		if (ro_ok) {
-			shm->diff = PTR_SUB(shm->ptr_ro, (char *) shm->ptr);
+			shm->base.readonlydiff = PTR_SUB(shm->ptr_ro, (char *) shm->ptr);
 			/* no overlap */
-			assert((xc_shmsize_t) abs(shm->diff) >= size);
+			assert((xc_shmsize_t) abs(shm->base.readonlydiff) >= size);
 		}
 		else {
 			if (shm->ptr_ro) {
@@ -256,7 +231,7 @@ static XC_SHM_INIT(xc_mmap_init) /* {{{
 			}
 #endif
 			shm->ptr_ro = NULL;
-			shm->diff = 0;
+			shm->base.readonlydiff = 0;
 		}
 	}
 
@@ -308,10 +283,10 @@ static XC_SHM_MEMDESTROY(xc_mmap_memdest
 }
 /* }}} */
 
-static xc_shm_handlers_t xc_shm_mmap_handlers = XC_SHM_HANDLERS(mmap);
+static xc_shm_vtable_t xc_shm_mmap_vtable = XC_SHM_VTABLE(mmap);
 void xc_shm_mmap_register() /* {{{ */
 {
-	if (xc_shm_scheme_register("mmap", &xc_shm_mmap_handlers) == 0) {
+	if (xc_shm_scheme_register("mmap", &xc_shm_mmap_vtable) == 0) {
 		zend_error(E_ERROR, "XCache: failed to register mmap shm_scheme");
 	}
 	return;
--- xcache.orig/mod_optimizer/xc_optimizer.c
+++ xcache/mod_optimizer/xc_optimizer.c
@@ -521,7 +521,7 @@ static int bbs_build_from(bbs_t *bbs, ze
 static void bbs_restore_opnum(bbs_t *bbs, zend_op_array *op_array) /* {{{ */
 {
 	int bbid;
-	zend_uint i;
+	int i;
 
 	for (bbid = 0; bbid < bbs_count(bbs); bbid ++) {
 		op_flowinfo_t fi;
--- xcache.orig/mod_cacher/xc_cacher.c
+++ xcache/mod_cacher/xc_cacher.c
@@ -159,6 +159,13 @@ typedef enum { XC_TYPE_PHP, XC_TYPE_VAR
 static void xc_holds_init(TSRMLS_D);
 static void xc_holds_destroy(TSRMLS_D);
 
+static void *xc_cache_storage(void *data, size_t size) /* {{{ */
+{
+	xc_allocator_t *allocator = (xc_allocator_t *) data;
+	return allocator->vtable->malloc(allocator, size);
+}
+/* }}} */
+
 /* any function in *_unlocked is only safe be called within locked (single thread access) area */
 
 static void xc_php_add_unlocked(xc_cached_t *cached, xc_entry_data_php_t *php) /* {{{ */
@@ -172,10 +179,40 @@ static void xc_php_add_unlocked(xc_cache
 static xc_entry_data_php_t *xc_php_store_unlocked(xc_cache_t *cache, xc_entry_data_php_t *php TSRMLS_DC) /* {{{ */
 {
 	xc_entry_data_php_t *stored_php;
+	xc_processor_storage_t storage;
+	storage.allocator      = &xc_cache_storage;
+	storage.allocator_data = (void *) cache->allocator;
+	storage.relocatediff   = cache->shm->readonlydiff;
 
 	php->hits     = 0;
 	php->refcount = 0;
-	stored_php = xc_processor_store_xc_entry_data_php_t(cache->shm, cache->allocator, php TSRMLS_CC);
+	stored_php = xc_processor_store_xc_entry_data_php_t(&storage, php TSRMLS_CC);
+#if 0
+	{
+		xc_entry_data_php_t *p = malloc(stored_php->size);
+		xc_entry_data_php_t *backup = malloc(stored_php->size);
+		fprintf(stderr, "%lu\n", stored_php->size);
+		memcpy(backup, stored_php, stored_php->size);
+
+		{
+			memcpy(p, stored_php, stored_php->size);
+			xc_processor_relocate_xc_entry_data_php_t(p, p , stored_php, stored_php TSRMLS_CC);
+			assert(memcmp(stored_php, backup, stored_php->size) == 0);
+
+			memcpy(stored_php, p, p->size);
+			xc_processor_relocate_xc_entry_data_php_t(stored_php, stored_php, p, p TSRMLS_CC);
+		}
+
+		{
+			memcpy(p, stored_php, stored_php->size);
+			xc_processor_relocate_xc_entry_data_php_t(p, 0, stored_php, stored_php TSRMLS_CC);
+			assert(memcmp(stored_php, backup, stored_php->size) == 0);
+
+			memcpy(stored_php, p, p->size);
+			xc_processor_relocate_xc_entry_data_php_t(stored_php, stored_php, p, 0 TSRMLS_CC);
+		}
+	}
+#endif
 	if (stored_php) {
 		xc_php_add_unlocked(cache->cached, stored_php);
 		return stored_php;
@@ -281,13 +318,17 @@ static void xc_entry_add_unlocked(xc_cac
 static xc_entry_t *xc_entry_store_unlocked(xc_entry_type_t type, xc_cache_t *cache, xc_hash_value_t entryslotid, xc_entry_t *entry TSRMLS_DC) /* {{{ */
 {
 	xc_entry_t *stored_entry;
+	xc_processor_storage_t storage;
+	storage.allocator      = &xc_cache_storage;
+	storage.allocator_data = (void *) cache->allocator;
+	storage.relocatediff   = cache->shm->readonlydiff;
 
 	entry->hits  = 0;
 	entry->ctime = XG(request_time);
 	entry->atime = XG(request_time);
 	stored_entry = type == XC_TYPE_PHP
-		? (xc_entry_t *) xc_processor_store_xc_entry_php_t(cache->shm, cache->allocator, (xc_entry_php_t *) entry TSRMLS_CC)
-		: (xc_entry_t *) xc_processor_store_xc_entry_var_t(cache->shm, cache->allocator, (xc_entry_var_t *) entry TSRMLS_CC);
+		? (xc_entry_t *) xc_processor_store_xc_entry_php_t(&storage, (xc_entry_php_t *) entry TSRMLS_CC)
+		: (xc_entry_t *) xc_processor_store_xc_entry_var_t(&storage, (xc_entry_var_t *) entry TSRMLS_CC);
 	if (stored_entry) {
 		xc_entry_add_unlocked(cache->cached, entryslotid, stored_entry);
 		++cache->cached->updates;
@@ -406,15 +447,15 @@ static inline zend_uint advance_wrapped(
 	return val + 1;
 }
 /* }}} */
-static inline void xc_counters_inc(time_t *curtime, zend_uint *curslot, time_t interval, zend_ulong *counters, zend_uint count TSRMLS_DC) /* {{{ */
+static inline void xc_counters_inc(time_t *curtime, zend_uint *curslot, time_t interval, zend_ulong *counters, zend_uint ncounters TSRMLS_DC) /* {{{ */
 {
 	time_t n = XG(request_time) / interval;
-	if (*curtime != n) {
-		zend_uint target_slot = ((zend_uint) n) % count;
+	if (*curtime < n) {
+		zend_uint target_slot = ((zend_uint) n) % ncounters;
 		zend_uint slot;
-		for (slot = advance_wrapped(*curslot, count);
+		for (slot = advance_wrapped(*curslot, ncounters);
 				slot != target_slot;
-				slot = advance_wrapped(slot, count)) {
+				slot = advance_wrapped(slot, ncounters)) {
 			counters[slot] = 0;
 		}
 		counters[target_slot] = 0;
@@ -424,6 +465,7 @@ static inline void xc_counters_inc(time_
 	counters[*curslot] ++;
 }
 /* }}} */
+#define xc_countof(array) (sizeof(array) / sizeof(array[0]))
 static inline void xc_cached_hit_unlocked(xc_cached_t *cached TSRMLS_DC) /* {{{ */
 {
 	cached->hits ++;
@@ -431,13 +473,13 @@ static inline void xc_cached_hit_unlocke
 	xc_counters_inc(&cached->hits_by_hour_cur_time
 			, &cached->hits_by_hour_cur_slot, 60 * 60
 			, cached->hits_by_hour
-			, sizeof(cached->hits_by_hour) / sizeof(cached->hits_by_hour[0])
+			, xc_countof(cached->hits_by_hour)
 			TSRMLS_CC);
 
 	xc_counters_inc(&cached->hits_by_second_cur_time
 			, &cached->hits_by_second_cur_slot, 1
 			, cached->hits_by_second
-			, sizeof(cached->hits_by_second) / sizeof(cached->hits_by_second[0])
+			, xc_countof(cached->hits_by_second)
 			TSRMLS_CC);
 }
 /* }}} */
@@ -624,14 +666,14 @@ static void xc_fillinfo_unlocked(int cac
 	}
 	MAKE_STD_ZVAL(hits);
 	array_init(hits);
-	for (i = 0; i < sizeof(cached->hits_by_hour) / sizeof(cached->hits_by_hour[0]); i ++) {
+	for (i = 0; i < xc_countof(cached->hits_by_hour); i ++) {
 		add_next_index_long(hits, (long) cached->hits_by_hour[i]);
 	}
 	add_assoc_zval_ex(return_value, XCACHE_STRS("hits_by_hour"), hits);
 
 	MAKE_STD_ZVAL(hits);
 	array_init(hits);
-	for (i = 0; i < sizeof(cached->hits_by_second) / sizeof(cached->hits_by_second[0]); i ++) {
+	for (i = 0; i < xc_countof(cached->hits_by_second); i ++) {
 		add_next_index_long(hits, (long) cached->hits_by_second[i]);
 	}
 	add_assoc_zval_ex(return_value, XCACHE_STRS("hits_by_second"), hits);
@@ -825,11 +867,6 @@ static zend_op_array *xc_entry_install(x
 	CG(zend_lineno) = 0;
 #endif
 
-	i = 1;
-#ifndef ZEND_ENGINE_2_2
-	zend_hash_add(&EG(included_files), entry_php->entry.name.str.val, entry_php->entry.name.str.len+1, (void *)&i, sizeof(int), NULL);
-#endif
-
 #ifndef ZEND_ENGINE_2
 	xc_free_alloca(new_cest_ptrs, use_heap);
 #endif
@@ -1726,14 +1763,14 @@ static void xc_compile_php(xc_compiler_t
 
 #define COPY_H(vartype, var, cnt, name, datatype) do {        \
 	for (i = 0, j = 0; b; i ++, b = b->pListNext) {           \
-		vartype *data = &compiler->new_php.var[j];                         \
+		vartype *data = &compiler->new_php.var[j];            \
                                                               \
 		if (i < old_##cnt) {                                  \
 			continue;                                         \
 		}                                                     \
 		j ++;                                                 \
                                                               \
-		assert(i < old_##cnt + compiler->new_php.cnt);                     \
+		assert(i < old_##cnt + compiler->new_php.cnt);        \
 		assert(b->pData);                                     \
 		memcpy(&data->name, b->pData, sizeof(datatype));      \
 		UNISW(NOTHING, data->type = b->key.type;)             \
@@ -2146,7 +2183,6 @@ static zend_op_array *xc_compile_file_ca
 
 	/* found entry */
 	if (stored_entry && stored_php) {
-		zend_llist_add_element(&CG(open_files), h);
 		return xc_compile_restore(stored_entry, stored_php TSRMLS_CC);
 	}
 
@@ -2214,7 +2250,7 @@ zend_bool xc_is_rw(const void *p) /* {{{
 	if (xc_php_caches) {
 		for (i = 0; i < xc_php_hcache.size; i ++) {
 			shm = xc_php_caches[i].shm;
-			if (shm->handlers->is_readwrite(shm, p)) {
+			if (shm->vtable->is_readwrite(shm, p)) {
 				return 1;
 			}
 		}
@@ -2223,7 +2259,7 @@ zend_bool xc_is_rw(const void *p) /* {{{
 	if (xc_var_caches) {
 		for (i = 0; i < xc_var_hcache.size; i ++) {
 			shm = xc_var_caches[i].shm;
-			if (shm->handlers->is_readwrite(shm, p)) {
+			if (shm->vtable->is_readwrite(shm, p)) {
 				return 1;
 			}
 		}
@@ -2239,7 +2275,7 @@ zend_bool xc_is_ro(const void *p) /* {{{
 	if (xc_php_caches) {
 		for (i = 0; i < xc_php_hcache.size; i ++) {
 			shm = xc_php_caches[i].shm;
-			if (shm->handlers->is_readonly(shm, p)) {
+			if (shm->vtable->is_readonly(shm, p)) {
 				return 1;
 			}
 		}
@@ -2248,7 +2284,7 @@ zend_bool xc_is_ro(const void *p) /* {{{
 	if (xc_var_caches) {
 		for (i = 0; i < xc_var_hcache.size; i ++) {
 			shm = xc_var_caches[i].shm;
-			if (shm->handlers->is_readonly(shm, p)) {
+			if (shm->vtable->is_readonly(shm, p)) {
 				return 1;
 			}
 		}
@@ -2611,7 +2647,7 @@ static xc_shm_t *xc_cache_destroy(xc_cac
 			}
 			shm = cache->shm;
 			if (shm) {
-				cache->shm->handlers->memdestroy(cache->allocator);
+				cache->shm->vtable->memdestroy(cache->allocator);
 			}
 		}
 	}
@@ -2644,7 +2680,7 @@ static xc_cache_t *xc_cache_init(xc_shm_
 
 	for (i = 0; i < hcache->size; i ++) {
 		xc_cache_t *cache = &caches[i];
-		CHECK(allocator = shm->handlers->meminit(shm, memsize), "Failed init shm");
+		CHECK(allocator = shm->vtable->meminit(shm, memsize), "Failed init shm");
 		if (!(allocator->vtable = xc_allocator_find(allocator_name))) {
 			zend_error(E_ERROR, "Allocator %s not found", allocator_name);
 			goto err;
@@ -2719,7 +2755,7 @@ static int xc_init() /* {{{ */
 
 	if (xc_php_size || xc_var_size) {
 		CHECK(shm = xc_shm_init(xc_shm_scheme, shmsize, xc_readonly_protection, xc_mmap_path, NULL), "Cannot create shm");
-		if (!shm->handlers->can_readonly(shm)) {
+		if (!xc_shm_can_readonly(shm)) {
 			xc_readonly_protection = 0;
 		}
 
@@ -3091,6 +3127,14 @@ static void xcache_admin_operate(xcache_
 /* }}} */
 /* {{{ proto int xcache_count(int type)
    Return count of cache on specified cache type */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_count, 0, 0, 1)
+	ZEND_ARG_INFO(0, type)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_count[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_count)
 {
 	xcache_admin_operate(XC_OP_COUNT, INTERNAL_FUNCTION_PARAM_PASSTHRU);
@@ -3098,6 +3142,15 @@ PHP_FUNCTION(xcache_count)
 /* }}} */
 /* {{{ proto array xcache_info(int type, int id)
    Get cache info by id on specified cache type */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_info, 0, 0, 2)
+	ZEND_ARG_INFO(0, type)
+	ZEND_ARG_INFO(0, id)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_info[] = { 2, BYREF_NONE, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_info)
 {
 	xcache_admin_operate(XC_OP_INFO, INTERNAL_FUNCTION_PARAM_PASSTHRU);
@@ -3105,6 +3158,15 @@ PHP_FUNCTION(xcache_info)
 /* }}} */
 /* {{{ proto array xcache_list(int type, int id)
    Get cache entries list by id on specified cache type */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_list, 0, 0, 2)
+	ZEND_ARG_INFO(0, type)
+	ZEND_ARG_INFO(0, id)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_list[] = { 2, BYREF_NONE, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_list)
 {
 	xcache_admin_operate(XC_OP_LIST, INTERNAL_FUNCTION_PARAM_PASSTHRU);
@@ -3112,6 +3174,15 @@ PHP_FUNCTION(xcache_list)
 /* }}} */
 /* {{{ proto array xcache_clear_cache(int type, [ int id = -1 ])
    Clear cache by id on specified cache type */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_clear_cache, 0, 0, 1)
+	ZEND_ARG_INFO(0, type)
+	ZEND_ARG_INFO(0, id)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_clear_cache[] = { 2, BYREF_NONE, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_clear_cache)
 {
 	xcache_admin_operate(XC_OP_CLEAR, INTERNAL_FUNCTION_PARAM_PASSTHRU);
@@ -3119,6 +3190,16 @@ PHP_FUNCTION(xcache_clear_cache)
 /* }}} */
 /* {{{ proto array xcache_enable_cache(int type, [ int id = -1, [ bool enable = true ] ])
    Enable or disable cache by id on specified cache type */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_enable_cache, 0, 0, 1)
+	ZEND_ARG_INFO(0, type)
+	ZEND_ARG_INFO(0, id)
+	ZEND_ARG_INFO(0, enable)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_enable_cache[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_enable_cache)
 {
 	xcache_admin_operate(XC_OP_ENABLE, INTERNAL_FUNCTION_PARAM_PASSTHRU);
@@ -3126,6 +3207,13 @@ PHP_FUNCTION(xcache_enable_cache)
 /* }}} */
 /* {{{ proto mixed xcache_admin_namespace()
    Break out of namespace limitation */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_admin_namespace, 0, 0, 0)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_admin_namespace[] = { 0 };
+#endif
+
 PHP_FUNCTION(xcache_admin_namespace)
 {
 	xcache_admin_auth_check(TSRMLS_C);
@@ -3157,6 +3245,14 @@ static int xc_entry_var_init_key(xc_entr
 /* }}} */
 /* {{{ proto mixed xcache_set_namespace(string namespace)
    Switch to user defined namespace */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_set_namespace, 0, 0, 1)
+	ZEND_ARG_INFO(0, namespace)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_set_namespace[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_set_namespace)
 {
 	zval *namespace;
@@ -3182,6 +3278,14 @@ PHP_FUNCTION(xcache_set_namespace)
 /* }}} */
 /* {{{ proto mixed xcache_get(string name)
    Get cached data by specified name */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_get, 0, 0, 1)
+	ZEND_ARG_INFO(0, name)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_get[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_get)
 {
 	xc_entry_hash_t entry_hash;
@@ -3223,6 +3327,16 @@ PHP_FUNCTION(xcache_get)
 /* }}} */
 /* {{{ proto bool  xcache_set(string name, mixed value [, int ttl])
    Store data to cache by specified name */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_set, 0, 0, 2)
+	ZEND_ARG_INFO(0, name)
+	ZEND_ARG_INFO(0, value)
+	ZEND_ARG_INFO(0, ttl)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_set[] = { 3, BYREF_NONE, BYREF_NONE, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_set)
 {
 	xc_entry_hash_t entry_hash;
@@ -3274,6 +3388,14 @@ PHP_FUNCTION(xcache_set)
 /* }}} */
 /* {{{ proto bool  xcache_isset(string name)
    Check if an entry exists in cache by specified name */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_isset, 0, 0, 1)
+	ZEND_ARG_INFO(0, name)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_isset[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_isset)
 {
 	xc_entry_hash_t entry_hash;
@@ -3316,6 +3438,14 @@ PHP_FUNCTION(xcache_isset)
 /* }}} */
 /* {{{ proto bool  xcache_unset(string name)
    Unset existing data in cache by specified name */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_unset, 0, 0, 1)
+	ZEND_ARG_INFO(0, name)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_unset[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_unset)
 {
 	xc_entry_hash_t entry_hash;
@@ -3356,6 +3486,14 @@ PHP_FUNCTION(xcache_unset)
 /* }}} */
 /* {{{ proto bool  xcache_unset_by_prefix(string prefix)
    Unset existing data in cache by specified prefix */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_unset_by_prefix, 0, 0, 1)
+	ZEND_ARG_INFO(0, prefix)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_unset_by_prefix[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_unset_by_prefix)
 {
 	zval *prefix;
@@ -3443,7 +3581,7 @@ static inline void xc_var_inc_dec(int in
 				value += (inc == 1 ? count : - count);
 				RETVAL_LONG(value);
 
-				zv = (zval *) cache->shm->handlers->to_readwrite(cache->shm, (char *) stored_entry_var->value);
+				zv = (zval *) xc_shm_to_readwrite(cache->shm, (char *) stored_entry_var->value);
 				Z_LVAL_P(zv) = value;
 				++cache->cached->updates;
 				break; /* leave lock */
@@ -3476,6 +3614,16 @@ static inline void xc_var_inc_dec(int in
 /* }}} */
 /* {{{ proto int xcache_inc(string name [, int value [, int ttl]])
    Increase an int counter in cache by specified name, create it if not exists */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_inc, 0, 0, 1)
+	ZEND_ARG_INFO(0, prefix)
+	ZEND_ARG_INFO(0, value)
+	ZEND_ARG_INFO(0, ttl)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_inc[] = { 3, BYREF_NONE, BYREF_NONE, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_inc)
 {
 	xc_var_inc_dec(1, INTERNAL_FUNCTION_PARAM_PASSTHRU);
@@ -3483,6 +3631,16 @@ PHP_FUNCTION(xcache_inc)
 /* }}} */
 /* {{{ proto int xcache_dec(string name [, int value [, int ttl]])
    Decrease an int counter in cache by specified name, create it if not exists */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_dec, 0, 0, 1)
+	ZEND_ARG_INFO(0, prefix)
+	ZEND_ARG_INFO(0, value)
+	ZEND_ARG_INFO(0, ttl)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_dec[] = { 3, BYREF_NONE, BYREF_NONE, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_dec)
 {
 	xc_var_inc_dec(-1, INTERNAL_FUNCTION_PARAM_PASSTHRU);
@@ -3490,20 +3648,20 @@ PHP_FUNCTION(xcache_dec)
 /* }}} */
 static zend_function_entry xcache_cacher_functions[] = /* {{{ */
 {
-	PHP_FE(xcache_count,             NULL)
-	PHP_FE(xcache_info,              NULL)
-	PHP_FE(xcache_list,              NULL)
-	PHP_FE(xcache_clear_cache,       NULL)
-	PHP_FE(xcache_enable_cache,      NULL)
-	PHP_FE(xcache_admin_namespace,   NULL)
-	PHP_FE(xcache_set_namespace,     NULL)
-	PHP_FE(xcache_get,               NULL)
-	PHP_FE(xcache_set,               NULL)
-	PHP_FE(xcache_isset,             NULL)
-	PHP_FE(xcache_unset,             NULL)
-	PHP_FE(xcache_unset_by_prefix,   NULL)
-	PHP_FE(xcache_inc,               NULL)
-	PHP_FE(xcache_dec,               NULL)
+	PHP_FE(xcache_count,             arginfo_xcache_count)
+	PHP_FE(xcache_info,              arginfo_xcache_info)
+	PHP_FE(xcache_list,              arginfo_xcache_list)
+	PHP_FE(xcache_clear_cache,       arginfo_xcache_clear_cache)
+	PHP_FE(xcache_enable_cache,      arginfo_xcache_enable_cache)
+	PHP_FE(xcache_admin_namespace,   arginfo_xcache_admin_namespace)
+	PHP_FE(xcache_set_namespace,     arginfo_xcache_set_namespace)
+	PHP_FE(xcache_get,               arginfo_xcache_get)
+	PHP_FE(xcache_set,               arginfo_xcache_set)
+	PHP_FE(xcache_isset,             arginfo_xcache_isset)
+	PHP_FE(xcache_unset,             arginfo_xcache_unset)
+	PHP_FE(xcache_unset_by_prefix,   arginfo_xcache_unset_by_prefix)
+	PHP_FE(xcache_inc,               arginfo_xcache_inc)
+	PHP_FE(xcache_dec,               arginfo_xcache_dec)
 	PHP_FE_END
 };
 /* }}} */
--- xcache.orig/mod_coverager/xc_coverager.c
+++ xcache/mod_coverager/xc_coverager.c
@@ -484,6 +484,14 @@ static void xc_coverager_handle_ext_stmt
 /* {{{ proto array xcache_coverager_decode(string data)
  * decode specified data which is saved by auto dumper to array
  */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_coverager_decode, 0, 0, 1)
+	ZEND_ARG_INFO(0, data)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_coverager_decode[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_coverager_decode)
 {
 	char *str;
@@ -514,6 +522,14 @@ PHP_FUNCTION(xcache_coverager_decode)
 /* {{{ proto void xcache_coverager_start([bool clean = true])
  * starts coverager data collecting
  */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_coverager_start, 0, 0, 0)
+	ZEND_ARG_INFO(0, clean)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_coverager_start[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_coverager_start)
 {
 	zend_bool clean = 1;
@@ -537,6 +553,14 @@ PHP_FUNCTION(xcache_coverager_start)
 /* {{{ proto void xcache_coverager_stop([bool clean = false])
  * stop coverager data collecting
  */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_coverager_stop, 0, 0, 0)
+	ZEND_ARG_INFO(0, clean)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_coverager_stop[] = { 1, BYREF_NONE };
+#endif
+
 PHP_FUNCTION(xcache_coverager_stop)
 {
 	zend_bool clean = 0;
@@ -554,6 +578,13 @@ PHP_FUNCTION(xcache_coverager_stop)
 /* {{{ proto array xcache_coverager_get([bool clean = false])
  * get coverager data collected
  */
+#ifdef ZEND_BEGIN_ARG_INFO_EX
+ZEND_BEGIN_ARG_INFO_EX(arginfo_xcache_coverager_get, 0, 0, 0)
+	ZEND_ARG_INFO(0, clean)
+ZEND_END_ARG_INFO()
+#else
+static unsigned char arginfo_xcache_coverager_get[] = { 1, BYREF_NONE };
+#endif
 PHP_FUNCTION(xcache_coverager_get)
 {
 	zend_bool clean = 0;
@@ -569,10 +600,10 @@ PHP_FUNCTION(xcache_coverager_get)
 /* }}} */
 static zend_function_entry xcache_coverager_functions[] = /* {{{ */
 {
-	PHP_FE(xcache_coverager_decode,  NULL)
-	PHP_FE(xcache_coverager_start,   NULL)
-	PHP_FE(xcache_coverager_stop,    NULL)
-	PHP_FE(xcache_coverager_get,     NULL)
+	PHP_FE(xcache_coverager_decode,  arginfo_xcache_coverager_decode)
+	PHP_FE(xcache_coverager_start,   arginfo_xcache_coverager_start)
+	PHP_FE(xcache_coverager_stop,    arginfo_xcache_coverager_stop)
+	PHP_FE(xcache_coverager_get,     arginfo_xcache_coverager_get)
 	PHP_FE_END
 };
 /* }}} */
--- /dev/null
+++ xcache/mod_assembler/xc_assembler.c
@@ -0,0 +1 @@
+static void dummy() { }
